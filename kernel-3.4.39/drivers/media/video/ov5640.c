
/*
 * OV5640 Camera Driver
 *
 * Copyright (C) 2011 Actions Semiconductor Co.,LTD
 * Wang Xin <wangxin@actions-semi.com>
 *
 *
 * Copyright (C) 2008 Renesas Solutions Corp.
 * Kuninori Morimoto <morimoto.kuninori@renesas.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * fixed by swpark@nexell.co.kr for compatibility with general v4l2 layer (not using soc camera interface)
 */


#include <linux/init.h>
#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <linux/v4l2-subdev.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-device.h>
#include <media/v4l2-subdev.h>
#include <media/v4l2-ctrls.h>


//#include "ov5640.h"


#define MODULE_NAME "OV5640"
/* private ctrls */
#define V4L2_CID_SCENE_EXPOSURE         (V4L2_CTRL_CLASS_CAMERA | 0x1001)
#define V4L2_CID_PRIVATE_PREV_CAPT      (V4L2_CTRL_CLASS_CAMERA | 0x1002)
#define NUM_CTRLS           11



#define OV5640_DBG 1

/* ANSI Color codes */
#define VT(CODES)  "\033[" CODES "m"
#define VT_NORMAL  VT("")
#define VT_RED     VT("0;32;31")
#define VT_GREEN   VT("1;32")
#define VT_YELLOW  VT("1;33")
#define VT_BLUE    VT("1;34")
#define VT_PURPLE  VT("0;35")


#define xprintk(fmt, ...) \
    printk("%s()->%d " fmt, __func__, __LINE__, ## __VA_ARGS__)

#ifdef OV5640_DBG

#define _DBG(color, fmt, ...)  \
    xprintk(color "" fmt VT_NORMAL, ## __VA_ARGS__)

#define OV_INFO(fmt, args...)  _DBG(VT_GREEN, fmt, ## args)
#define OV_ERR(fmt, args...)   _DBG(VT_RED, fmt, ## args)
#else
#define OV_INFO(fmt, args...)  do {} while(0)
#define OV_ERR(fmt, args...) do {} while(0)
#endif

#define _INFO(color, fmt, ...) \
    xprintk(color "::" fmt ""VT_NORMAL, ## __VA_ARGS__)


#define INFO_PURLPLE(fmt, args...) _INFO(VT_PURPLE, fmt, ## args)
#define INFO_RED(fmt, args...)     _INFO(VT_RED, fmt, ## args)
#define INFO_GREEN(fmt, args...)   _INFO(VT_GREEN, fmt, ## args)
#define INFO_BLUE(fmt, args...)    _INFO(VT_BLUE, fmt, ## args)



#define ENDMARKER { 0xff, 0xff }


/* add by dg 2015-07-15*/

/*************************************************************************
* FUNCTION
*   OV5640_FOCUS_AD5820_Init
*
* DESCRIPTION
*   This function is to load micro code for AF function
*
* PARAMETERS
*   None
*
* RETURNS
*   None
*
* GLOBALS AFFECTED
*
*************************************************************************/
static u8 AD5820_Config[] =
{
    0x02, 0x0f, 0xd6, 0x02, 0x0a, 0x39, 0xc2, 0x01, 0x22, 0x22, 0x00, 0x02, 0x0f, 0xb2, 0xe5, 0x1f, //0x8000,
    0x70, 0x72, 0xf5, 0x1e, 0xd2, 0x35, 0xff, 0xef, 0x25, 0xe0, 0x24, 0x4e, 0xf8, 0xe4, 0xf6, 0x08, //0x8010,
    0xf6, 0x0f, 0xbf, 0x34, 0xf2, 0x90, 0x0e, 0x93, 0xe4, 0x93, 0xff, 0xe5, 0x4b, 0xc3, 0x9f, 0x50, //0x8020,
    0x04, 0x7f, 0x05, 0x80, 0x02, 0x7f, 0xfb, 0x78, 0xbd, 0xa6, 0x07, 0x12, 0x0f, 0x04, 0x40, 0x04, //0x8030,
    0x7f, 0x03, 0x80, 0x02, 0x7f, 0x30, 0x78, 0xbc, 0xa6, 0x07, 0xe6, 0x18, 0xf6, 0x08, 0xe6, 0x78, //0x8040,
    0xb9, 0xf6, 0x78, 0xbc, 0xe6, 0x78, 0xba, 0xf6, 0x78, 0xbf, 0x76, 0x33, 0xe4, 0x08, 0xf6, 0x78, //0x8050,
    0xb8, 0x76, 0x01, 0x75, 0x4a, 0x02, 0x78, 0xb6, 0xf6, 0x08, 0xf6, 0x74, 0xff, 0x78, 0xc1, 0xf6, //0x8060,
    0x08, 0xf6, 0x75, 0x1f, 0x01, 0x78, 0xbc, 0xe6, 0x75, 0xf0, 0x05, 0xa4, 0xf5, 0x4b, 0x12, 0x0a, //0x8070,
    0xff, 0xc2, 0x37, 0x22, 0x78, 0xb8, 0xe6, 0xd3, 0x94, 0x00, 0x40, 0x02, 0x16, 0x22, 0xe5, 0x1f, //0x8080,
    0xb4, 0x05, 0x23, 0xe4, 0xf5, 0x1f, 0xc2, 0x01, 0x78, 0xb6, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x78, //0x8090,
    0x4e, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0xa2, 0x37, 0xe4, 0x33, 0xf5, 0x3c, 0x90, 0x30, 0x28, 0xf0, //0x80a0,
    0x75, 0x1e, 0x10, 0xd2, 0x35, 0x22, 0xe5, 0x4b, 0x75, 0xf0, 0x05, 0x84, 0x78, 0xbc, 0xf6, 0x90, //0x80b0,
    0x0e, 0x8c, 0xe4, 0x93, 0xff, 0x25, 0xe0, 0x24, 0x0a, 0xf8, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x78, //0x80c0,
    0xbc, 0xe6, 0x25, 0xe0, 0x24, 0x4e, 0xf8, 0xa6, 0x04, 0x08, 0xa6, 0x05, 0xef, 0x12, 0x0f, 0x0b, //0x80d0,
    0xd3, 0x78, 0xb7, 0x96, 0xee, 0x18, 0x96, 0x40, 0x0d, 0x78, 0xbc, 0xe6, 0x78, 0xb9, 0xf6, 0x78, //0x80e0,
    0xb6, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x90, 0x0e, 0x8c, 0xe4, 0x93, 0x12, 0x0f, 0x0b, 0xc3, 0x78, //0x80f0,
    0xc2, 0x96, 0xee, 0x18, 0x96, 0x50, 0x0d, 0x78, 0xbc, 0xe6, 0x78, 0xba, 0xf6, 0x78, 0xc1, 0xa6, //0x8100,
    0x06, 0x08, 0xa6, 0x07, 0x78, 0xb6, 0xe6, 0xfe, 0x08, 0xe6, 0xc3, 0x78, 0xc2, 0x96, 0xff, 0xee, //0x8110,
    0x18, 0x96, 0x78, 0xc3, 0xf6, 0x08, 0xa6, 0x07, 0x90, 0x0e, 0x95, 0xe4, 0x18, 0x12, 0x0e, 0xe9, //0x8120,
    0x40, 0x02, 0xd2, 0x37, 0x78, 0xbc, 0xe6, 0x08, 0x26, 0x08, 0xf6, 0xe5, 0x1f, 0x64, 0x01, 0x70, //0x8130,
    0x4a, 0xe6, 0xc3, 0x78, 0xc0, 0x12, 0x0e, 0xdf, 0x40, 0x05, 0x12, 0x0e, 0xda, 0x40, 0x39, 0x12, //0x8140,
    0x0f, 0x02, 0x40, 0x04, 0x7f, 0xfe, 0x80, 0x02, 0x7f, 0x02, 0x78, 0xbd, 0xa6, 0x07, 0x78, 0xb9, //0x8150,
    0xe6, 0x24, 0x03, 0x78, 0xbf, 0xf6, 0x78, 0xb9, 0xe6, 0x24, 0xfd, 0x78, 0xc0, 0xf6, 0x12, 0x0f, //0x8160,
    0x02, 0x40, 0x06, 0x78, 0xc0, 0xe6, 0xff, 0x80, 0x04, 0x78, 0xbf, 0xe6, 0xff, 0x78, 0xbe, 0xa6, //0x8170,
    0x07, 0x75, 0x1f, 0x02, 0x78, 0xb8, 0x76, 0x01, 0x02, 0x02, 0x4a, 0xe5, 0x1f, 0x64, 0x02, 0x60, //0x8180,
    0x03, 0x02, 0x02, 0x2a, 0x78, 0xbe, 0xe6, 0xff, 0xc3, 0x78, 0xc0, 0x12, 0x0e, 0xe0, 0x40, 0x08, //0x8190,
    0x12, 0x0e, 0xda, 0x50, 0x03, 0x02, 0x02, 0x28, 0x12, 0x0f, 0x02, 0x40, 0x04, 0x7f, 0xff, 0x80, //0x81a0,
    0x02, 0x7f, 0x01, 0x78, 0xbd, 0xa6, 0x07, 0x78, 0xb9, 0xe6, 0x04, 0x78, 0xbf, 0xf6, 0x78, 0xb9, //0x81b0,
    0xe6, 0x14, 0x78, 0xc0, 0xf6, 0x18, 0x12, 0x0f, 0x04, 0x40, 0x04, 0xe6, 0xff, 0x80, 0x02, 0x7f, //0x81c0,
    0x00, 0x78, 0xbf, 0xa6, 0x07, 0xd3, 0x08, 0xe6, 0x64, 0x80, 0x94, 0x80, 0x40, 0x04, 0xe6, 0xff, //0x81d0,
    0x80, 0x02, 0x7f, 0x00, 0x78, 0xc0, 0xa6, 0x07, 0xc3, 0x18, 0xe6, 0x64, 0x80, 0x94, 0xb3, 0x50, //0x81e0,
    0x04, 0xe6, 0xff, 0x80, 0x02, 0x7f, 0x33, 0x78, 0xbf, 0xa6, 0x07, 0xc3, 0x08, 0xe6, 0x64, 0x80, //0x81f0,
    0x94, 0xb3, 0x50, 0x04, 0xe6, 0xff, 0x80, 0x02, 0x7f, 0x33, 0x78, 0xc0, 0xa6, 0x07, 0x12, 0x0f, //0x8200,
    0x02, 0x40, 0x06, 0x78, 0xc0, 0xe6, 0xff, 0x80, 0x04, 0x78, 0xbf, 0xe6, 0xff, 0x78, 0xbe, 0xa6, //0x8210,
    0x07, 0x75, 0x1f, 0x03, 0x78, 0xb8, 0x76, 0x01, 0x80, 0x20, 0xe5, 0x1f, 0x64, 0x03, 0x70, 0x26, //0x8220,
    0x78, 0xbe, 0xe6, 0xff, 0xc3, 0x78, 0xc0, 0x12, 0x0e, 0xe0, 0x40, 0x05, 0x12, 0x0e, 0xda, 0x40, //0x8230,
    0x09, 0x78, 0xb9, 0xe6, 0x78, 0xbe, 0xf6, 0x75, 0x1f, 0x04, 0x78, 0xbe, 0xe6, 0x75, 0xf0, 0x05, //0x8240,
    0xa4, 0xf5, 0x4b, 0x02, 0x0a, 0xff, 0xe5, 0x1f, 0xb4, 0x04, 0x10, 0x90, 0x0e, 0x94, 0xe4, 0x78, //0x8250,
    0xc3, 0x12, 0x0e, 0xe9, 0x40, 0x02, 0xd2, 0x37, 0x75, 0x1f, 0x05, 0x22, 0x30, 0x01, 0x03, 0x02, //0x8260,
    0x04, 0xc0, 0x30, 0x02, 0x03, 0x02, 0x04, 0xc0, 0x90, 0x51, 0xa5, 0xe0, 0x78, 0x93, 0xf6, 0xa3, //0x8270,
    0xe0, 0x08, 0xf6, 0xa3, 0xe0, 0x08, 0xf6, 0xe5, 0x1f, 0x70, 0x3c, 0x75, 0x1e, 0x20, 0xd2, 0x35, //0x8280,
    0x12, 0x0c, 0x7a, 0x78, 0x7e, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x78, 0x8b, 0xa6, 0x09, 0x18, 0x76, //0x8290,
    0x01, 0x12, 0x0c, 0x5b, 0x78, 0x4e, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x78, 0x8b, 0xe6, 0x78, 0x6e, //0x82a0,
    0xf6, 0x75, 0x1f, 0x01, 0x78, 0x93, 0xe6, 0x78, 0x90, 0xf6, 0x78, 0x94, 0xe6, 0x78, 0x91, 0xf6, //0x82b0,
    0x78, 0x95, 0xe6, 0x78, 0x92, 0xf6, 0x22, 0x79, 0x90, 0xe7, 0xd3, 0x78, 0x93, 0x96, 0x40, 0x05, //0x82c0,
    0xe7, 0x96, 0xff, 0x80, 0x08, 0xc3, 0x79, 0x93, 0xe7, 0x78, 0x90, 0x96, 0xff, 0x78, 0x88, 0x76, //0x82d0,
    0x00, 0x08, 0xa6, 0x07, 0x79, 0x91, 0xe7, 0xd3, 0x78, 0x94, 0x96, 0x40, 0x05, 0xe7, 0x96, 0xff, //0x82e0,
    0x80, 0x08, 0xc3, 0x79, 0x94, 0xe7, 0x78, 0x91, 0x96, 0xff, 0x12, 0x0c, 0x8e, 0x79, 0x92, 0xe7, //0x82f0,
    0xd3, 0x78, 0x95, 0x96, 0x40, 0x05, 0xe7, 0x96, 0xff, 0x80, 0x08, 0xc3, 0x79, 0x95, 0xe7, 0x78, //0x8300,
    0x92, 0x96, 0xff, 0x12, 0x0c, 0x8e, 0x12, 0x0c, 0x5b, 0x78, 0x8a, 0xe6, 0x25, 0xe0, 0x24, 0x4e, //0x8310,
    0xf8, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x78, 0x8a, 0xe6, 0x24, 0x6e, 0xf8, 0xa6, 0x09, 0x78, 0x8a, //0x8320,
    0xe6, 0x24, 0x01, 0xff, 0xe4, 0x33, 0xfe, 0xd3, 0xef, 0x94, 0x0f, 0xee, 0x64, 0x80, 0x94, 0x80, //0x8330,
    0x40, 0x04, 0x7f, 0x00, 0x80, 0x05, 0x78, 0x8a, 0xe6, 0x04, 0xff, 0x78, 0x8a, 0xa6, 0x07, 0xe5, //0x8340,
    0x1f, 0xb4, 0x01, 0x0a, 0xe6, 0x60, 0x03, 0x02, 0x04, 0xc0, 0x75, 0x1f, 0x02, 0x22, 0x12, 0x0c, //0x8350,
    0x7a, 0x78, 0x80, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x12, 0x0c, 0x7a, 0x78, 0x82, 0xa6, 0x06, 0x08, //0x8360,
    0xa6, 0x07, 0x78, 0x6e, 0xe6, 0x78, 0x8c, 0xf6, 0x78, 0x6e, 0xe6, 0x78, 0x8d, 0xf6, 0x7f, 0x01, //0x8370,
    0xef, 0x25, 0xe0, 0x24, 0x4f, 0xf9, 0xc3, 0x78, 0x81, 0xe6, 0x97, 0x18, 0xe6, 0x19, 0x97, 0x50, //0x8380,
    0x0a, 0x12, 0x0c, 0x82, 0x78, 0x80, 0xa6, 0x04, 0x08, 0xa6, 0x05, 0x74, 0x6e, 0x2f, 0xf9, 0x78, //0x8390,
    0x8c, 0xe6, 0xc3, 0x97, 0x50, 0x08, 0x74, 0x6e, 0x2f, 0xf8, 0xe6, 0x78, 0x8c, 0xf6, 0xef, 0x25, //0x83a0,
    0xe0, 0x24, 0x4f, 0xf9, 0xd3, 0x78, 0x83, 0xe6, 0x97, 0x18, 0xe6, 0x19, 0x97, 0x40, 0x0a, 0x12, //0x83b0,
    0x0c, 0x82, 0x78, 0x82, 0xa6, 0x04, 0x08, 0xa6, 0x05, 0x74, 0x6e, 0x2f, 0xf9, 0x78, 0x8d, 0xe6, //0x83c0,
    0xd3, 0x97, 0x40, 0x08, 0x74, 0x6e, 0x2f, 0xf8, 0xe6, 0x78, 0x8d, 0xf6, 0x0f, 0xef, 0x64, 0x10, //0x83d0,
    0x70, 0x9e, 0xc3, 0x79, 0x81, 0xe7, 0x78, 0x83, 0x96, 0xff, 0x19, 0xe7, 0x18, 0x96, 0x78, 0x84, //0x83e0,
    0xf6, 0x08, 0xa6, 0x07, 0xc3, 0x79, 0x8c, 0xe7, 0x78, 0x8d, 0x96, 0x08, 0xf6, 0xd3, 0x79, 0x81, //0x83f0,
    0xe7, 0x78, 0x7f, 0x96, 0x19, 0xe7, 0x18, 0x96, 0x40, 0x05, 0x09, 0xe7, 0x08, 0x80, 0x06, 0xc3, //0x8400,
    0x79, 0x7f, 0xe7, 0x78, 0x81, 0x96, 0xff, 0x19, 0xe7, 0x18, 0x96, 0xfe, 0x78, 0x86, 0xa6, 0x06, //0x8410,
    0x08, 0xa6, 0x07, 0x79, 0x8c, 0xe7, 0xd3, 0x78, 0x8b, 0x96, 0x40, 0x05, 0xe7, 0x96, 0xff, 0x80, //0x8420,
    0x08, 0xc3, 0x79, 0x8b, 0xe7, 0x78, 0x8c, 0x96, 0xff, 0x78, 0x8f, 0xa6, 0x07, 0xe5, 0x1f, 0x64, //0x8430,
    0x02, 0x70, 0x69, 0x90, 0x0e, 0x91, 0x93, 0xff, 0x18, 0xe6, 0xc3, 0x9f, 0x50, 0x72, 0x12, 0x0c, //0x8440,
    0x4a, 0x12, 0x0c, 0x2f, 0x90, 0x0e, 0x8e, 0x12, 0x0c, 0x38, 0x78, 0x80, 0x12, 0x0c, 0x6b, 0x7b, //0x8450,
    0x04, 0x12, 0x0c, 0x1d, 0xc3, 0x12, 0x06, 0x45, 0x50, 0x56, 0x90, 0x0e, 0x92, 0xe4, 0x93, 0xff, //0x8460,
    0x78, 0x8f, 0xe6, 0x9f, 0x40, 0x02, 0x80, 0x11, 0x90, 0x0e, 0x90, 0xe4, 0x93, 0xff, 0xd3, 0x78, //0x8470,
    0x89, 0xe6, 0x9f, 0x18, 0xe6, 0x94, 0x00, 0x40, 0x03, 0x75, 0x1f, 0x05, 0x12, 0x0c, 0x4a, 0x12, //0x8480,
    0x0c, 0x2f, 0x90, 0x0e, 0x8f, 0x12, 0x0c, 0x38, 0x78, 0x7e, 0x12, 0x0c, 0x6b, 0x7b, 0x40, 0x12, //0x8490,
    0x0c, 0x1d, 0xd3, 0x12, 0x06, 0x45, 0x40, 0x18, 0x75, 0x1f, 0x05, 0x22, 0xe5, 0x1f, 0xb4, 0x05, //0x84a0,
    0x0f, 0xd2, 0x01, 0xc2, 0x02, 0xe4, 0xf5, 0x1f, 0xf5, 0x1e, 0xd2, 0x35, 0xd2, 0x33, 0xd2, 0x36, //0x84b0,
    0x22, 0xef, 0x8d, 0xf0, 0xa4, 0xa8, 0xf0, 0xcf, 0x8c, 0xf0, 0xa4, 0x28, 0xce, 0x8d, 0xf0, 0xa4, //0x84c0,
    0x2e, 0xfe, 0x22, 0xbc, 0x00, 0x0b, 0xbe, 0x00, 0x29, 0xef, 0x8d, 0xf0, 0x84, 0xff, 0xad, 0xf0, //0x84d0,
    0x22, 0xe4, 0xcc, 0xf8, 0x75, 0xf0, 0x08, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xec, 0x33, 0xfc, //0x84e0,
    0xee, 0x9d, 0xec, 0x98, 0x40, 0x05, 0xfc, 0xee, 0x9d, 0xfe, 0x0f, 0xd5, 0xf0, 0xe9, 0xe4, 0xce, //0x84f0,
    0xfd, 0x22, 0xed, 0xf8, 0xf5, 0xf0, 0xee, 0x84, 0x20, 0xd2, 0x1c, 0xfe, 0xad, 0xf0, 0x75, 0xf0, //0x8500,
    0x08, 0xef, 0x2f, 0xff, 0xed, 0x33, 0xfd, 0x40, 0x07, 0x98, 0x50, 0x06, 0xd5, 0xf0, 0xf2, 0x22, //0x8510,
    0xc3, 0x98, 0xfd, 0x0f, 0xd5, 0xf0, 0xea, 0x22, 0xe8, 0x8f, 0xf0, 0xa4, 0xcc, 0x8b, 0xf0, 0xa4, //0x8520,

    0x2c, 0xfc, 0xe9, 0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed, 0xa4, 0x2c, 0xfc, 0xea, 0x8e, //0x8530,
    0xf0, 0xa4, 0xcd, 0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38, 0x25, 0xf0, 0xfd, 0xe9, 0x8f, //0x8540,
    0xf0, 0xa4, 0x2c, 0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4, 0xfe, 0xa9, 0xf0, 0xeb, 0x8f, //0x8550,
    0xf0, 0xa4, 0xcf, 0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c, 0xfc, 0xea, 0xa4, 0x2d, 0xce, //0x8560,
    0x35, 0xf0, 0xfd, 0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x08, 0x75, 0x82, 0x00, 0xef, 0x2f, 0xff, //0x8570,
    0xee, 0x33, 0xfe, 0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82, 0x33, 0xc5, 0x82, 0x9b, 0xed, //0x8580,
    0x9a, 0xec, 0x99, 0xe5, 0x82, 0x98, 0x40, 0x0c, 0xf5, 0x82, 0xee, 0x9b, 0xfe, 0xed, 0x9a, 0xfd, //0x8590,
    0xec, 0x99, 0xfc, 0x0f, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4, 0xcd, 0xfa, 0xe4, 0xcc, 0xf9, //0x85a0,
    0xa8, 0x82, 0x22, 0xb8, 0x00, 0xc1, 0xb9, 0x00, 0x59, 0xba, 0x00, 0x2d, 0xec, 0x8b, 0xf0, 0x84, //0x85b0,
    0xcf, 0xce, 0xcd, 0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, //0x85c0,
    0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7, 0x03, 0x99, 0x40, 0x04, 0xeb, //0x85d0,
    0x99, 0xfb, 0x0f, 0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, //0x85e0,
    0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10, 0xd7, 0x05, 0x9b, 0xe9, 0x9a, //0x85f0,
    0x40, 0x07, 0xec, 0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0x0f, 0xd8, 0xe0, 0xe4, 0xc9, 0xfa, 0xe4, 0xcc, //0x8600,
    0xfb, 0x22, 0x75, 0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xcc, 0x33, //0x8610,
    0xcc, 0xc8, 0x33, 0xc8, 0x10, 0xd7, 0x07, 0x9b, 0xec, 0x9a, 0xe8, 0x99, 0x40, 0x0a, 0xed, 0x9b, //0x8620,
    0xfd, 0xec, 0x9a, 0xfc, 0xe8, 0x99, 0xf8, 0x0f, 0xd5, 0xf0, 0xda, 0xe4, 0xcd, 0xfb, 0xe4, 0xcc, //0x8630,
    0xfa, 0xe4, 0xc8, 0xf9, 0x22, 0xeb, 0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9, 0x9d, 0x42, //0x8640,
    0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22, 0xe8, 0x60, 0x0f, 0xec, 0xc3, 0x13, 0xfc, 0xed, 0x13, 0xfd, //0x8650,
    0xee, 0x13, 0xfe, 0xef, 0x13, 0xff, 0xd8, 0xf1, 0x22, 0xe8, 0x60, 0x0f, 0xef, 0xc3, 0x33, 0xff, //0x8660,
    0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe4, 0x93, 0xfc, 0x74, //0x8670,
    0x01, 0x93, 0xfd, 0x74, 0x02, 0x93, 0xfe, 0x74, 0x03, 0x93, 0xff, 0x22, 0xe6, 0xfb, 0x08, 0xe6, //0x8680,
    0xf9, 0x08, 0xe6, 0xfa, 0x08, 0xe6, 0xcb, 0xf8, 0x22, 0xec, 0xf6, 0x08, 0xed, 0xf6, 0x08, 0xee, //0x8690,
    0xf6, 0x08, 0xef, 0xf6, 0x22, 0xa4, 0x25, 0x82, 0xf5, 0x82, 0xe5, 0xf0, 0x35, 0x83, 0xf5, 0x83, //0x86a0,
    0x22, 0xd0, 0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, //0x86b0,
    0xa3, 0x93, 0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, //0x86c0,
    0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80, 0xdf, 0x90, 0x38, 0x04, 0x78, 0x52, 0x12, 0x0b, 0xfd, 0x90, //0x86d0,
    0x38, 0x00, 0xe0, 0xfe, 0xa3, 0xe0, 0xfd, 0xed, 0xff, 0xc3, 0x12, 0x0b, 0x9e, 0x90, 0x38, 0x10, //0x86e0,
    0x12, 0x0b, 0x92, 0x90, 0x38, 0x06, 0x78, 0x54, 0x12, 0x0b, 0xfd, 0x90, 0x38, 0x02, 0xe0, 0xfe, //0x86f0,
    0xa3, 0xe0, 0xfd, 0xed, 0xff, 0xc3, 0x12, 0x0b, 0x9e, 0x90, 0x38, 0x12, 0x12, 0x0b, 0x92, 0xa3, //0x8700,
    0xe0, 0xb4, 0x31, 0x07, 0x78, 0x52, 0x79, 0x52, 0x12, 0x0c, 0x13, 0x90, 0x38, 0x14, 0xe0, 0xb4, //0x8710,
    0x71, 0x15, 0x78, 0x52, 0xe6, 0xfe, 0x08, 0xe6, 0x78, 0x02, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, //0x8720,
    0xf9, 0x79, 0x53, 0xf7, 0xee, 0x19, 0xf7, 0x90, 0x38, 0x15, 0xe0, 0xb4, 0x31, 0x07, 0x78, 0x54, //0x8730,
    0x79, 0x54, 0x12, 0x0c, 0x13, 0x90, 0x38, 0x15, 0xe0, 0xb4, 0x71, 0x15, 0x78, 0x54, 0xe6, 0xfe, //0x8740,
    0x08, 0xe6, 0x78, 0x02, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x79, 0x55, 0xf7, 0xee, 0x19, //0x8750,
    0xf7, 0x79, 0x52, 0x12, 0x0b, 0xd9, 0x09, 0x12, 0x0b, 0xd9, 0xaf, 0x47, 0x12, 0x0b, 0xb2, 0xe5, //0x8760,
    0x44, 0xfb, 0x7a, 0x00, 0xfd, 0x7c, 0x00, 0x12, 0x04, 0xd3, 0x78, 0x5a, 0xa6, 0x06, 0x08, 0xa6, //0x8770,
    0x07, 0xaf, 0x45, 0x12, 0x0b, 0xb2, 0xad, 0x03, 0x7c, 0x00, 0x12, 0x04, 0xd3, 0x78, 0x56, 0xa6, //0x8780,
    0x06, 0x08, 0xa6, 0x07, 0xaf, 0x48, 0x78, 0x54, 0x12, 0x0b, 0xb4, 0xe5, 0x43, 0xfb, 0xfd, 0x7c, //0x8790,
    0x00, 0x12, 0x04, 0xd3, 0x78, 0x5c, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0xaf, 0x46, 0x7e, 0x00, 0x78, //0x87a0,
    0x54, 0x12, 0x0b, 0xb6, 0xad, 0x03, 0x7c, 0x00, 0x12, 0x04, 0xd3, 0x78, 0x58, 0xa6, 0x06, 0x08, //0x87b0,
    0xa6, 0x07, 0xc3, 0x78, 0x5b, 0xe6, 0x94, 0x08, 0x18, 0xe6, 0x94, 0x00, 0x50, 0x05, 0x76, 0x00, //0x87c0,
    0x08, 0x76, 0x08, 0xc3, 0x78, 0x5d, 0xe6, 0x94, 0x08, 0x18, 0xe6, 0x94, 0x00, 0x50, 0x05, 0x76, //0x87d0,
    0x00, 0x08, 0x76, 0x08, 0x78, 0x5a, 0x12, 0x0b, 0xc6, 0xff, 0xd3, 0x78, 0x57, 0xe6, 0x9f, 0x18, //0x87e0,
    0xe6, 0x9e, 0x40, 0x0e, 0x78, 0x5a, 0xe6, 0x13, 0xfe, 0x08, 0xe6, 0x78, 0x57, 0x12, 0x0c, 0x08, //0x87f0,
    0x80, 0x04, 0x7e, 0x00, 0x7f, 0x00, 0x78, 0x5e, 0x12, 0x0b, 0xbe, 0xff, 0xd3, 0x78, 0x59, 0xe6, //0x8800,
    0x9f, 0x18, 0xe6, 0x9e, 0x40, 0x0e, 0x78, 0x5c, 0xe6, 0x13, 0xfe, 0x08, 0xe6, 0x78, 0x59, 0x12, //0x8810,
    0x0c, 0x08, 0x80, 0x04, 0x7e, 0x00, 0x7f, 0x00, 0xe4, 0xfc, 0xfd, 0x78, 0x62, 0x12, 0x06, 0x99, //0x8820,
    0x78, 0x5a, 0x12, 0x0b, 0xc6, 0x78, 0x57, 0x26, 0xff, 0xee, 0x18, 0x36, 0xfe, 0x78, 0x66, 0x12, //0x8830,
    0x0b, 0xbe, 0x78, 0x59, 0x26, 0xff, 0xee, 0x18, 0x36, 0xfe, 0xe4, 0xfc, 0xfd, 0x78, 0x6a, 0x12, //0x8840,
    0x06, 0x99, 0x12, 0x0b, 0xce, 0x78, 0x66, 0x12, 0x06, 0x8c, 0xd3, 0x12, 0x06, 0x45, 0x40, 0x08, //0x8850,
    0x12, 0x0b, 0xce, 0x78, 0x66, 0x12, 0x06, 0x99, 0x78, 0x54, 0x12, 0x0b, 0xd0, 0x78, 0x6a, 0x12, //0x8860,
    0x06, 0x8c, 0xd3, 0x12, 0x06, 0x45, 0x40, 0x0a, 0x78, 0x54, 0x12, 0x0b, 0xd0, 0x78, 0x6a, 0x12, //0x8870,
    0x06, 0x99, 0x78, 0x61, 0xe6, 0x90, 0x60, 0x01, 0xf0, 0x78, 0x65, 0xe6, 0xa3, 0xf0, 0x78, 0x69, //0x8880,
    0xe6, 0xa3, 0xf0, 0x78, 0x55, 0xe6, 0xa3, 0xf0, 0x7d, 0x01, 0x78, 0x61, 0x12, 0x0b, 0xe9, 0x24, //0x8890,
    0x01, 0x12, 0x0b, 0xa6, 0x78, 0x65, 0x12, 0x0b, 0xe9, 0x24, 0x02, 0x12, 0x0b, 0xa6, 0x78, 0x69, //0x88a0,
    0x12, 0x0b, 0xe9, 0x24, 0x03, 0x12, 0x0b, 0xa6, 0x78, 0x6d, 0x12, 0x0b, 0xe9, 0x24, 0x04, 0x12, //0x88b0,
    0x0b, 0xa6, 0x0d, 0xbd, 0x05, 0xd4, 0xc2, 0x0e, 0xc2, 0x06, 0x22, 0x85, 0x08, 0x41, 0x90, 0x30, //0x88c0,
    0x24, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0, 0xf5, 0x3e, 0xa3, 0xe0, 0xf5, 0x3f, 0xa3, 0xe0, 0xf5, 0x40, //0x88d0,
    0xa3, 0xe0, 0xf5, 0x3c, 0xd2, 0x34, 0xe5, 0x41, 0x12, 0x06, 0xb1, 0x09, 0x31, 0x03, 0x09, 0x35, //0x88e0,
    0x04, 0x09, 0x3b, 0x05, 0x09, 0x3e, 0x06, 0x09, 0x41, 0x07, 0x09, 0x4a, 0x08, 0x09, 0x5b, 0x12, //0x88f0,
    0x09, 0x73, 0x18, 0x09, 0x89, 0x19, 0x09, 0x5e, 0x1a, 0x09, 0x6a, 0x1b, 0x09, 0xad, 0x80, 0x09, //0x8900,
    0xb2, 0x81, 0x0a, 0x1d, 0x8f, 0x0a, 0x09, 0x90, 0x0a, 0x1d, 0x91, 0x0a, 0x1d, 0x92, 0x0a, 0x1d, //0x8910,
    0x93, 0x0a, 0x1d, 0x94, 0x0a, 0x1d, 0x98, 0x0a, 0x17, 0x9f, 0x0a, 0x1a, 0xec, 0x00, 0x00, 0x0a, //0x8920,
    0x38, 0x12, 0x0f, 0x74, 0x22, 0x12, 0x0f, 0x74, 0xd2, 0x03, 0x22, 0xd2, 0x03, 0x22, 0xc2, 0x03, //0x8930,
    0x22, 0xa2, 0x37, 0xe4, 0x33, 0xf5, 0x3c, 0x02, 0x0a, 0x1d, 0xc2, 0x01, 0xc2, 0x02, 0xc2, 0x03, //0x8940,
    0x12, 0x0d, 0x0d, 0x75, 0x1e, 0x70, 0xd2, 0x35, 0x02, 0x0a, 0x1d, 0x02, 0x0a, 0x04, 0x85, 0x40, //0x8950,
    0x4a, 0x85, 0x3c, 0x4b, 0x12, 0x0a, 0xff, 0x02, 0x0a, 0x1d, 0x85, 0x4a, 0x40, 0x85, 0x4b, 0x3c, //0x8960,
    0x02, 0x0a, 0x1d, 0xe4, 0xf5, 0x22, 0xf5, 0x23, 0x85, 0x40, 0x31, 0x85, 0x3f, 0x30, 0x85, 0x3e, //0x8970,
    0x2f, 0x85, 0x3d, 0x2e, 0x12, 0x0f, 0x46, 0x80, 0x1f, 0x75, 0x22, 0x00, 0x75, 0x23, 0x01, 0x74, //0x8980,
    0xff, 0xf5, 0x2d, 0xf5, 0x2c, 0xf5, 0x2b, 0xf5, 0x2a, 0x12, 0x0f, 0x46, 0x85, 0x2d, 0x40, 0x85, //0x8990,
    0x2c, 0x3f, 0x85, 0x2b, 0x3e, 0x85, 0x2a, 0x3d, 0xe4, 0xf5, 0x3c, 0x80, 0x70, 0x12, 0x0f, 0x16, //0x89a0,
    0x80, 0x6b, 0x85, 0x3d, 0x45, 0x85, 0x3e, 0x46, 0xe5, 0x47, 0xc3, 0x13, 0xff, 0xe5, 0x45, 0xc3, //0x89b0,
    0x9f, 0x50, 0x02, 0x8f, 0x45, 0xe5, 0x48, 0xc3, 0x13, 0xff, 0xe5, 0x46, 0xc3, 0x9f, 0x50, 0x02, //0x89c0,
    0x8f, 0x46, 0xe5, 0x47, 0xc3, 0x13, 0xff, 0xfd, 0xe5, 0x45, 0x2d, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, //0x89d0,
    0x44, 0x12, 0x0f, 0x90, 0x40, 0x05, 0xe5, 0x44, 0x9f, 0xf5, 0x45, 0xe5, 0x48, 0xc3, 0x13, 0xff, //0x89e0,
    0xfd, 0xe5, 0x46, 0x2d, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x43, 0x12, 0x0f, 0x90, 0x40, 0x05, 0xe5, //0x89f0,
    0x43, 0x9f, 0xf5, 0x46, 0x12, 0x06, 0xd7, 0x80, 0x14, 0x85, 0x40, 0x48, 0x85, 0x3f, 0x47, 0x85, //0x8a00,
    0x3e, 0x46, 0x85, 0x3d, 0x45, 0x80, 0x06, 0x02, 0x06, 0xd7, 0x12, 0x0d, 0x7e, 0x90, 0x30, 0x24, //0x8a10,
    0xe5, 0x3d, 0xf0, 0xa3, 0xe5, 0x3e, 0xf0, 0xa3, 0xe5, 0x3f, 0xf0, 0xa3, 0xe5, 0x40, 0xf0, 0xa3, //0x8a20,
    0xe5, 0x3c, 0xf0, 0x90, 0x30, 0x23, 0xe4, 0xf0, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, //0x8a30,
    0xd0, 0x90, 0x3f, 0x0c, 0xe0, 0xf5, 0x32, 0xe5, 0x32, 0x30, 0xe3, 0x74, 0x30, 0x36, 0x66, 0x90, //0x8a40,
    0x60, 0x19, 0xe0, 0xf5, 0x0a, 0xa3, 0xe0, 0xf5, 0x0b, 0x90, 0x60, 0x1d, 0xe0, 0xf5, 0x14, 0xa3, //0x8a50,
    0xe0, 0xf5, 0x15, 0x90, 0x60, 0x21, 0xe0, 0xf5, 0x0c, 0xa3, 0xe0, 0xf5, 0x0d, 0x90, 0x60, 0x29, //0x8a60,
    0xe0, 0xf5, 0x0e, 0xa3, 0xe0, 0xf5, 0x0f, 0x90, 0x60, 0x31, 0xe0, 0xf5, 0x10, 0xa3, 0xe0, 0xf5, //0x8a70,
    0x11, 0x90, 0x60, 0x39, 0xe0, 0xf5, 0x12, 0xa3, 0xe0, 0xf5, 0x13, 0x30, 0x01, 0x06, 0x30, 0x33, //0x8a80,
    0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x09, 0x30, 0x02, 0x06, 0x30, 0x33, 0x03, 0xd3, 0x80, 0x01, //0x8a90,
    0xc3, 0x92, 0x0a, 0x30, 0x33, 0x0c, 0x30, 0x03, 0x09, 0x20, 0x02, 0x06, 0x20, 0x01, 0x03, 0xd3, //0x8aa0,
    0x80, 0x01, 0xc3, 0x92, 0x0b, 0x90, 0x30, 0x01, 0xe0, 0x44, 0x40, 0xf0, 0xe0, 0x54, 0xbf, 0xf0, //0x8ab0,
    0xe5, 0x32, 0x30, 0xe1, 0x14, 0x30, 0x34, 0x11, 0x90, 0x30, 0x22, 0xe0, 0xf5, 0x08, 0xe4, 0xf0, //0x8ac0,
    0x30, 0x00, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x08, 0xe5, 0x32, 0x30, 0xe5, 0x12, 0x90, 0x56, //0x8ad0,
    0xa1, 0xe0, 0xf5, 0x09, 0x30, 0x31, 0x09, 0x30, 0x05, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x0d, //0x8ae0,
    0x90, 0x3f, 0x0c, 0xe5, 0x32, 0xf0, 0xd0, 0xd0, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, //0x8af0,
    0x0e, 0x7e, 0xe4, 0x93, 0xfe, 0x74, 0x01, 0x93, 0xff, 0xc3, 0x90, 0x0e, 0x7c, 0x74, 0x01, 0x93, //0x8b00,
    0x9f, 0xff, 0xe4, 0x93, 0x9e, 0xfe, 0xe4, 0x8f, 0x3b, 0x8e, 0x3a, 0xf5, 0x39, 0xf5, 0x38, 0xab, //0x8b10,
    0x3b, 0xaa, 0x3a, 0xa9, 0x39, 0xa8, 0x38, 0xaf, 0x4b, 0xfc, 0xfd, 0xfe, 0x12, 0x05, 0x28, 0x12, //0x8b20,
    0x0d, 0xe1, 0xe4, 0x7b, 0xff, 0xfa, 0xf9, 0xf8, 0x12, 0x05, 0xb3, 0x12, 0x0d, 0xe1, 0x90, 0x0e, //0x8b30,
    0x69, 0xe4, 0x12, 0x0d, 0xf6, 0x12, 0x0d, 0xe1, 0xe4, 0x85, 0x4a, 0x37, 0xf5, 0x36, 0xf5, 0x35, //0x8b40,
    0xf5, 0x34, 0xaf, 0x37, 0xae, 0x36, 0xad, 0x35, 0xac, 0x34, 0xa3, 0x12, 0x0d, 0xf6, 0x8f, 0x37, //0x8b50,
    0x8e, 0x36, 0x8d, 0x35, 0x8c, 0x34, 0xe5, 0x3b, 0x45, 0x37, 0xf5, 0x3b, 0xe5, 0x3a, 0x45, 0x36, //0x8b60,
    0xf5, 0x3a, 0xe5, 0x39, 0x45, 0x35, 0xf5, 0x39, 0xe5, 0x38, 0x45, 0x34, 0xf5, 0x38, 0xe4, 0xf5, //0x8b70,
    0x22, 0xf5, 0x23, 0x85, 0x3b, 0x31, 0x85, 0x3a, 0x30, 0x85, 0x39, 0x2f, 0x85, 0x38, 0x2e, 0x02, //0x8b80,
    0x0f, 0x46, 0xe0, 0xa3, 0xe0, 0x75, 0xf0, 0x02, 0xa4, 0xff, 0xae, 0xf0, 0xc3, 0x08, 0xe6, 0x9f, //0x8b90,
    0xf6, 0x18, 0xe6, 0x9e, 0xf6, 0x22, 0xff, 0xe5, 0xf0, 0x34, 0x60, 0x8f, 0x82, 0xf5, 0x83, 0xec, //0x8ba0,
    0xf0, 0x22, 0x78, 0x52, 0x7e, 0x00, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x02, 0x04, 0xc1, 0xe4, 0xfc, //0x8bb0,
    0xfd, 0x12, 0x06, 0x99, 0x78, 0x5c, 0xe6, 0xc3, 0x13, 0xfe, 0x08, 0xe6, 0x13, 0x22, 0x78, 0x52, //0x8bc0,
    0xe6, 0xfe, 0x08, 0xe6, 0xff, 0xe4, 0xfc, 0xfd, 0x22, 0xe7, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0x68, //0x8bd0,
    0xf7, 0x09, 0xe7, 0xc4, 0x54, 0x0f, 0x48, 0xf7, 0x22, 0xe6, 0xfc, 0xed, 0x75, 0xf0, 0x04, 0xa4, //0x8be0,
    0x22, 0x12, 0x06, 0x7c, 0x8f, 0x48, 0x8e, 0x47, 0x8d, 0x46, 0x8c, 0x45, 0x22, 0xe0, 0xfe, 0xa3, //0x8bf0,
    0xe0, 0xfd, 0xee, 0xf6, 0xed, 0x08, 0xf6, 0x22, 0x13, 0xff, 0xc3, 0xe6, 0x9f, 0xff, 0x18, 0xe6, //0x8c00,
    0x9e, 0xfe, 0x22, 0xe6, 0xc3, 0x13, 0xf7, 0x08, 0xe6, 0x13, 0x09, 0xf7, 0x22, 0xad, 0x39, 0xac, //0x8c10,
    0x38, 0xfa, 0xf9, 0xf8, 0x12, 0x05, 0x28, 0x8f, 0x3b, 0x8e, 0x3a, 0x8d, 0x39, 0x8c, 0x38, 0xab, //0x8c20,
    0x37, 0xaa, 0x36, 0xa9, 0x35, 0xa8, 0x34, 0x22, 0x93, 0xff, 0xe4, 0xfc, 0xfd, 0xfe, 0x12, 0x05, //0x8c30,
    0x28, 0x8f, 0x37, 0x8e, 0x36, 0x8d, 0x35, 0x8c, 0x34, 0x22, 0x78, 0x84, 0xe6, 0xfe, 0x08, 0xe6, //0x8c40,
    0xff, 0xe4, 0x8f, 0x37, 0x8e, 0x36, 0xf5, 0x35, 0xf5, 0x34, 0x22, 0x90, 0x0e, 0x8c, 0xe4, 0x93, //0x8c50,
    0x25, 0xe0, 0x24, 0x0a, 0xf8, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x22, 0xe6, 0xfe, 0x08, 0xe6, 0xff, //0x8c60,
    0xe4, 0x8f, 0x3b, 0x8e, 0x3a, 0xf5, 0x39, 0xf5, 0x38, 0x22, 0x78, 0x4e, 0xe6, 0xfe, 0x08, 0xe6, //0x8c70,
    0xff, 0x22, 0xef, 0x25, 0xe0, 0x24, 0x4e, 0xf8, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x22, 0x78, 0x89, //0x8c80,
    0xef, 0x26, 0xf6, 0x18, 0xe4, 0x36, 0xf6, 0x22, 0x75, 0x89, 0x03, 0x75, 0xa8, 0x01, 0x75, 0xb8, //0x8c90,
    0x04, 0x75, 0x34, 0xff, 0x75, 0x35, 0x0e, 0x75, 0x36, 0x15, 0x75, 0x37, 0x0d, 0x12, 0x0e, 0x9a, //0x8ca0,
    0x12, 0x00, 0x09, 0x12, 0x0f, 0x16, 0x12, 0x00, 0x06, 0xd2, 0x00, 0xd2, 0x34, 0xd2, 0xaf, 0x75, //0x8cb0,
    0x34, 0xff, 0x75, 0x35, 0x0e, 0x75, 0x36, 0x49, 0x75, 0x37, 0x03, 0x12, 0x0e, 0x9a, 0x30, 0x08, //0x8cc0,
    0x09, 0xc2, 0x34, 0x12, 0x08, 0xcb, 0xc2, 0x08, 0xd2, 0x34, 0x30, 0x0b, 0x09, 0xc2, 0x36, 0x12, //0x8cd0,
    0x02, 0x6c, 0xc2, 0x0b, 0xd2, 0x36, 0x30, 0x09, 0x09, 0xc2, 0x36, 0x12, 0x00, 0x0e, 0xc2, 0x09, //0x8ce0,
    0xd2, 0x36, 0x30, 0x0e, 0x03, 0x12, 0x06, 0xd7, 0x30, 0x35, 0xd3, 0x90, 0x30, 0x29, 0xe5, 0x1e, //0x8cf0,
    0xf0, 0xb4, 0x10, 0x05, 0x90, 0x30, 0x23, 0xe4, 0xf0, 0xc2, 0x35, 0x80, 0xc1, 0xe4, 0xf5, 0x4b, //0x8d00,
    0x90, 0x0e, 0x7a, 0x93, 0xff, 0xe4, 0x8f, 0x37, 0xf5, 0x36, 0xf5, 0x35, 0xf5, 0x34, 0xaf, 0x37, //0x8d10,
    0xae, 0x36, 0xad, 0x35, 0xac, 0x34, 0x90, 0x0e, 0x6a, 0x12, 0x0d, 0xf6, 0x8f, 0x37, 0x8e, 0x36, //0x8d20,
    0x8d, 0x35, 0x8c, 0x34, 0x90, 0x0e, 0x72, 0x12, 0x06, 0x7c, 0xef, 0x45, 0x37, 0xf5, 0x37, 0xee, //0x8d30,
    0x45, 0x36, 0xf5, 0x36, 0xed, 0x45, 0x35, 0xf5, 0x35, 0xec, 0x45, 0x34, 0xf5, 0x34, 0xe4, 0xf5, //0x8d40,
    0x22, 0xf5, 0x23, 0x85, 0x37, 0x31, 0x85, 0x36, 0x30, 0x85, 0x35, 0x2f, 0x85, 0x34, 0x2e, 0x12, //0x8d50,
    0x0f, 0x46, 0xe4, 0xf5, 0x22, 0xf5, 0x23, 0x90, 0x0e, 0x72, 0x12, 0x0d, 0xea, 0x12, 0x0f, 0x46, //0x8d60,
    0xe4, 0xf5, 0x22, 0xf5, 0x23, 0x90, 0x0e, 0x6e, 0x12, 0x0d, 0xea, 0x02, 0x0f, 0x46, 0xe5, 0x40, //0x8d70,
    0x24, 0xf2, 0xf5, 0x37, 0xe5, 0x3f, 0x34, 0x43, 0xf5, 0x36, 0xe5, 0x3e, 0x34, 0xa2, 0xf5, 0x35, //0x8d80,
    0xe5, 0x3d, 0x34, 0x28, 0xf5, 0x34, 0xe5, 0x37, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 0x78, 0x18, 0x12, //0x8d90,
    0x06, 0x69, 0x8f, 0x40, 0x8e, 0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0xe5, 0x37, 0x54, 0xa0, 0xff, 0xe5, //0x8da0,
    0x36, 0xfe, 0xe4, 0xfd, 0xfc, 0x78, 0x07, 0x12, 0x06, 0x56, 0x78, 0x10, 0x12, 0x0f, 0x9a, 0xe4, //0x8db0,
    0xff, 0xfe, 0xe5, 0x35, 0xfd, 0xe4, 0xfc, 0x78, 0x0e, 0x12, 0x06, 0x56, 0x12, 0x0f, 0x9d, 0xe4, //0x8dc0,
    0xff, 0xfe, 0xfd, 0xe5, 0x34, 0xfc, 0x78, 0x18, 0x12, 0x06, 0x56, 0x78, 0x08, 0x12, 0x0f, 0x9a, //0x8dd0,
    0x22, 0x8f, 0x3b, 0x8e, 0x3a, 0x8d, 0x39, 0x8c, 0x38, 0x22, 0x12, 0x06, 0x7c, 0x8f, 0x31, 0x8e, //0x8de0,
    0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0x22, 0x93, 0xf9, 0xf8, 0x02, 0x06, 0x69, 0x00, 0x00, 0x00, 0x00, //0x8df0,
    0x12, 0x01, 0x17, 0x08, 0x31, 0x15, 0x53, 0x54, 0x44, 0x20, 0x20, 0x20, 0x20, 0x20, 0x13, 0x01, //0x8e00,
    0x10, 0x01, 0x56, 0x40, 0x1a, 0x30, 0x29, 0x7e, 0x00, 0x30, 0x04, 0x20, 0xdf, 0x30, 0x05, 0x40, //0x8e10,
    0xbf, 0x50, 0x03, 0x00, 0xfd, 0x50, 0x27, 0x01, 0xfe, 0x60, 0x00, 0x11, 0x00, 0x3f, 0x05, 0x30, //0x8e20,
    0x00, 0x3f, 0x06, 0x22, 0x00, 0x3f, 0x01, 0x2a, 0x00, 0x3f, 0x02, 0x00, 0x00, 0x36, 0x06, 0x07, //0x8e30,
    0x00, 0x3f, 0x0b, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x01, 0x40, 0xbf, 0x30, 0x01, 0x00, //0x8e40,
    0xbf, 0x30, 0x29, 0x70, 0x00, 0x3a, 0x00, 0x00, 0xff, 0x3a, 0x00, 0x00, 0xff, 0x36, 0x03, 0x36, //0x8e50,
    0x02, 0x41, 0x44, 0x58, 0x20, 0x18, 0x10, 0x0a, 0x04, 0x04, 0x00, 0x03, 0xff, 0x64, 0x00, 0x00, //0x8e60,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x06, 0x00, 0x03, 0x51, 0x00, 0x7a, //0x8e70,
    0x50, 0x3c, 0x28, 0x1e, 0x10, 0x10, 0x50, 0x2d, 0x28, 0x16, 0x10, 0x10, 0x02, 0x00, 0x10, 0x0c, //0x8e80,
    0x10, 0x04, 0x0c, 0x6e, 0x06, 0x05, 0x00, 0xa5, 0x5a, 0x00, 0xae, 0x35, 0xaf, 0x36, 0xe4, 0xfd, //0x8e90,
    0xed, 0xc3, 0x95, 0x37, 0x50, 0x33, 0x12, 0x0f, 0xe2, 0xe4, 0x93, 0xf5, 0x38, 0x74, 0x01, 0x93, //0x8ea0,
    0xf5, 0x39, 0x45, 0x38, 0x60, 0x23, 0x85, 0x39, 0x82, 0x85, 0x38, 0x83, 0xe0, 0xfc, 0x12, 0x0f, //0x8eb0,
    0xe2, 0x74, 0x03, 0x93, 0x52, 0x04, 0x12, 0x0f, 0xe2, 0x74, 0x02, 0x93, 0x42, 0x04, 0x85, 0x39, //0x8ec0,
    0x82, 0x85, 0x38, 0x83, 0xec, 0xf0, 0x0d, 0x80, 0xc7, 0x22, 0x78, 0xbe, 0xe6, 0xd3, 0x08, 0xff, //0x8ed0,
    0xe6, 0x64, 0x80, 0xf8, 0xef, 0x64, 0x80, 0x98, 0x22, 0x93, 0xff, 0x7e, 0x00, 0xe6, 0xfc, 0x08, //0x8ee0,
    0xe6, 0xfd, 0x12, 0x04, 0xc1, 0x78, 0xc1, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0xd3, 0xef, 0x9d, 0xee, //0x8ef0,
    0x9c, 0x22, 0x78, 0xbd, 0xd3, 0xe6, 0x64, 0x80, 0x94, 0x80, 0x22, 0x25, 0xe0, 0x24, 0x0a, 0xf8, //0x8f00,
    0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x22, 0xe5, 0x3c, 0xd3, 0x94, 0x00, 0x40, 0x0b, 0x90, 0x0e, 0x88, //0x8f10,
    0x12, 0x0b, 0xf1, 0x90, 0x0e, 0x86, 0x80, 0x09, 0x90, 0x0e, 0x82, 0x12, 0x0b, 0xf1, 0x90, 0x0e, //0x8f20,
    0x80, 0xe4, 0x93, 0xf5, 0x44, 0xa3, 0xe4, 0x93, 0xf5, 0x43, 0xd2, 0x06, 0x30, 0x06, 0x03, 0xd3, //0x8f30,
    0x80, 0x01, 0xc3, 0x92, 0x0e, 0x22, 0xa2, 0xaf, 0x92, 0x32, 0xc2, 0xaf, 0xe5, 0x23, 0x45, 0x22, //0x8f40,
    0x90, 0x0e, 0x5d, 0x60, 0x0e, 0x12, 0x0f, 0xcb, 0xe0, 0xf5, 0x2c, 0x12, 0x0f, 0xc8, 0xe0, 0xf5, //0x8f50,
    0x2d, 0x80, 0x0c, 0x12, 0x0f, 0xcb, 0xe5, 0x30, 0xf0, 0x12, 0x0f, 0xc8, 0xe5, 0x31, 0xf0, 0xa2, //0x8f60,
    0x32, 0x92, 0xaf, 0x22, 0xd2, 0x01, 0xc2, 0x02, 0xe4, 0xf5, 0x1f, 0xf5, 0x1e, 0xd2, 0x35, 0xd2, //0x8f70,
    0x33, 0xd2, 0x36, 0xd2, 0x01, 0xc2, 0x02, 0xf5, 0x1f, 0xf5, 0x1e, 0xd2, 0x35, 0xd2, 0x33, 0x22, //0x8f80,
    0xfb, 0xd3, 0xed, 0x9b, 0x74, 0x80, 0xf8, 0x6c, 0x98, 0x22, 0x12, 0x06, 0x69, 0xe5, 0x40, 0x2f, //0x8f90,
    0xf5, 0x40, 0xe5, 0x3f, 0x3e, 0xf5, 0x3f, 0xe5, 0x3e, 0x3d, 0xf5, 0x3e, 0xe5, 0x3d, 0x3c, 0xf5, //0x8fa0,
    0x3d, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0x90, 0x3f, 0x0d, 0xe0, 0xf5, 0x33, 0xe5, 0x33, //0x8fb0,
    0xf0, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x0e, 0x5f, 0xe4, 0x93, 0xfe, 0x74, 0x01, //0x8fc0,
    0x93, 0xf5, 0x82, 0x8e, 0x83, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0xcd, 0x02, //0x8fd0,
    0x0c, 0x98, 0x8f, 0x82, 0x8e, 0x83, 0x75, 0xf0, 0x04, 0xed, 0x02, 0x06, 0xa5,                   //0x8fe0

};

#define SENSORDB(fmt, arg...)  printk(fmt, ##arg)
static struct timeval OV5640YUV_ktv1, OV5640YUV_ktv2;
struct i2c_client * g_client=NULL;

#define UINT32  unsigned int
#define  UINT8  u8

typedef enum
{
    OV5640_720P,       //1M 1280x960
    OV5640_5M,     //5M 2592x1944
} OV5640_RES_TYPE;
OV5640_RES_TYPE OV5640YUV_g_RES=OV5640_720P;

typedef enum
{
    OV5640_MODE_PREVIEW,  //1M  	1280x960
    OV5640_MODE_CAPTURE   //5M    2592x1944
} OV5640_MODE;


OV5640_MODE g_iOV5640YUV_Mode=OV5640_MODE_PREVIEW;


#define KAL_FALSE false
#define KAL_TRUE  true
#define kal_uint32  unsigned int
#define kal_uint16  u16
#define kal_uint8  unsigned char
#define UINT16  u16
#define UINT8   unsigned char
#define  kal_bool  bool
#define Sleep   msleep

UINT8 OV5640YUVPixelClockDivider=0;
kal_uint32 OV5640YUV_sensor_pclk=56000000;
kal_uint32 OV5640YUV_PV_pclk = 5600;
kal_uint32 OV5640YUV_CAP_pclk = 5600;
kal_uint16 OV5640YUV_pv_exposure_lines=0x100,OV5640YUV_g_iBackupExtraExp = 0,OV5640YUV_extra_exposure_lines = 0;
kal_uint16 OV5640YUV_sensor_id=0;
//MSDK_SENSOR_CONFIG_STRUCT OV5640YUVSensorConfigData;
kal_uint32 OV5640YUV_FAC_SENSOR_REG;
kal_uint16 OV5640YUV_sensor_flip_value;


//liuxinming add
kal_uint32 back_shutter = 0;
kal_uint32 back_pv_gain = 0;
kal_uint32 tem = 0;



bool  OV5640YUV_MPEG4_encode_mode = KAL_FALSE;
bool  OV5640YUV_night_mode = KAL_FALSE;

#define  ERROR_NONE  1

static int i2cc_get_reg(struct i2c_client *client,
                        unsigned short reg, unsigned char *value)
{
    unsigned char buffer[2];
    int ret = 0;
    int err = 0;

    buffer[0] = (reg >> 8) & 0xFF;
    buffer[1] = reg & 0xFF;
    if (2 != (ret = i2c_master_send(client, buffer, 2))) {
        err = -2;
        OV_ERR("i2cc out error: ret == %d (should be 2)\n", ret);
    }

    if (1 != (ret = i2c_master_recv(client, buffer, 1))) {
        err = -1;
        OV_ERR("i2cc in error: ret == %d (should be 1)\n", ret);
    }
    //OV_INFO("ov5640 client: read 0x%x = 0x%x\n", reg, buffer[0]);
    *value = buffer[0];

    return (err);
}


static int i2cc_set_reg(struct i2c_client *client,
                        unsigned short reg, unsigned char value)
{
    unsigned char buffer[3];
    int ret = 0;
    int err = 0;

    buffer[0] = (reg >> 8) & 0xFF;
    buffer[1] = reg & 0xFF;
    buffer[2] = value;
    //OV_INFO("ov5640 client: writing 0x%x = 0x%x\n", reg, value);
    if (3 != (ret = i2c_master_send(client, buffer, 3))) {
        OV_ERR("i2cc out error: ret = %d (should be 3)\n", ret);
        err = -3;
    }
    return (err);
}


inline void OV5640YUV_imgSensorProfileStart(void)
{
    do_gettimeofday(&OV5640YUV_ktv1);
}

inline void OV5640YUV_imgSensorProfileEnd(char *tag)
{
    unsigned long TimeIntervalUS;
    do_gettimeofday(&OV5640YUV_ktv2);

    TimeIntervalUS = (OV5640YUV_ktv2.tv_sec - OV5640YUV_ktv1.tv_sec) * 1000000 + (OV5640YUV_ktv2.tv_usec - OV5640YUV_ktv1.tv_usec);
    SENSORDB("[%s]Profile = %lu\n",tag, TimeIntervalUS);
}


u8  OV5640YUV_read_cmos_sensor(u16 addr)
{
    unsigned char value=0;

     i2cc_get_reg(g_client,addr,&value);

     return value;
}

void OV5640YUV_write_cmos_sensor(u16 addr,u32 param)
{
      i2cc_set_reg(g_client,addr,param);
}



static void OV5640_FOCUS_AD5820_Check_MCU()
{
    u8 check[13] = {0x00};
    //mcu on
    check[0] = OV5640YUV_read_cmos_sensor(0x3000);
    check[1] = OV5640YUV_read_cmos_sensor(0x3004);
    //soft reset of mcu
    check[2] = OV5640YUV_read_cmos_sensor(0x3f00);
    //afc on
    check[3] = OV5640YUV_read_cmos_sensor(0x3001);
    check[4] = OV5640YUV_read_cmos_sensor(0x3005);
    //gpio1,gpio2
    check[5] = OV5640YUV_read_cmos_sensor(0x3018);
    check[6] = OV5640YUV_read_cmos_sensor(0x301e);
    check[7] = OV5640YUV_read_cmos_sensor(0x301b);
    check[8] = OV5640YUV_read_cmos_sensor(0x3042);
    //y0
    check[9] = OV5640YUV_read_cmos_sensor(0x3018);
    check[10] = OV5640YUV_read_cmos_sensor(0x301e);
    check[11] = OV5640YUV_read_cmos_sensor(0x301b);
    check[12] = OV5640YUV_read_cmos_sensor(0x3042);

    int i = 0;
    for(i = 0; i < 13; i++)
        SENSORDB("check[%d]=0x%x\n", i, check[i]);
}





static void OV5640_FOCUS_AD5820_Init(void)
{
    u8 state=0x8F;
    unsigned int  iteration = 100;
    int totalCnt = 0;
    int sentCnt = 0;
    int index=0;
    u16 addr = 0x8000;
    u8 buf[256];
    int len = 128;


  //  OV5640YUV_imgSensorProfileStart();
    OV5640YUV_write_cmos_sensor(0x3000, 0x20);
    totalCnt = ARRAY_SIZE(AD5820_Config);

#if 0//Brust mode
    while (index < totalCnt) {
        sentCnt = totalCnt - index > len  ? len  : totalCnt - index;
        buf[0] = addr >> 8;
        buf[1] = addr & 0xff;
        memcpy(&buf[2], &AD5820_Config[index], len );
        OV5640YUV_multi_write_cmos_sensor(buf, sentCnt + 2);
        addr += len ;
        index += len ;
    }
#else//single mode
    for(sentCnt =0; sentCnt<totalCnt; sentCnt++)
    {
        OV5640YUV_write_cmos_sensor(addr,AD5820_Config[sentCnt]);
        addr++;
    }
#endif
    mdelay(10);
    OV5640YUV_write_cmos_sensor(0x3022, 0x00);
    OV5640YUV_write_cmos_sensor(0x3023, 0x00);
    OV5640YUV_write_cmos_sensor(0x3024, 0x00);
    OV5640YUV_write_cmos_sensor(0x3025, 0x00);
    OV5640YUV_write_cmos_sensor(0x3026, 0x00);
    OV5640YUV_write_cmos_sensor(0x3027, 0x00);
    OV5640YUV_write_cmos_sensor(0x3028, 0x00);
    OV5640YUV_write_cmos_sensor(0x3029, 0x7f);
    OV5640YUV_write_cmos_sensor(0x3000, 0x00);

    do {
        state = (u8)OV5640YUV_read_cmos_sensor(0x3029);

        mdelay(5);
        if (iteration-- == 0)
        {
            break;
        }
    } while(state!=0x70);

    OV5640YUV_imgSensorProfileEnd("OV5640_FOCUS_AD5820_Init");
    OV5640_FOCUS_AD5820_Check_MCU();
    return;
}   /*  OV5640_FOCUS_AD5820_Init  */

void OV5640YUV_Sensor_Dvp_Init(void)
{
    OV5640YUV_write_cmos_sensor(0x4740, 0x20);//liuxinming

    OV5640YUV_write_cmos_sensor(0x3008, 0x42);
    OV5640YUV_write_cmos_sensor(0x3103, 0x03);
    OV5640YUV_write_cmos_sensor(0x3017, 0x7f);
    OV5640YUV_write_cmos_sensor(0x3018, 0xff);
    OV5640YUV_write_cmos_sensor(0x302c, 0x82);
    OV5640YUV_write_cmos_sensor(0x3108, 0x01);
    OV5640YUV_write_cmos_sensor(0x3630, 0x2e);//2e
    OV5640YUV_write_cmos_sensor(0x3632, 0xe2);
    OV5640YUV_write_cmos_sensor(0x3633, 0x23);//23
    OV5640YUV_write_cmos_sensor(0x3621, 0xe0);
    OV5640YUV_write_cmos_sensor(0x3704, 0xa0);
    OV5640YUV_write_cmos_sensor(0x3703, 0x5a);
    OV5640YUV_write_cmos_sensor(0x3715, 0x78);
    OV5640YUV_write_cmos_sensor(0x3717, 0x01);
    OV5640YUV_write_cmos_sensor(0x370b, 0x60);
    OV5640YUV_write_cmos_sensor(0x3705, 0x1a);
    OV5640YUV_write_cmos_sensor(0x3905, 0x02);
    OV5640YUV_write_cmos_sensor(0x3906, 0x10);
    OV5640YUV_write_cmos_sensor(0x3901, 0x0a);
    OV5640YUV_write_cmos_sensor(0x3731, 0x12);
    OV5640YUV_write_cmos_sensor(0x3600, 0x08);
    OV5640YUV_write_cmos_sensor(0x3601, 0x33);
    OV5640YUV_write_cmos_sensor(0x302d, 0x60);
    OV5640YUV_write_cmos_sensor(0x3620, 0x52);
    OV5640YUV_write_cmos_sensor(0x371b, 0x20);
    OV5640YUV_write_cmos_sensor(0x471c, 0x50);

    OV5640YUV_write_cmos_sensor(0x3a18, 0x00);
    OV5640YUV_write_cmos_sensor(0x3a19, 0xf8);

    OV5640YUV_write_cmos_sensor(0x3635, 0x1c);//1c
    OV5640YUV_write_cmos_sensor(0x3634, 0x40);
    OV5640YUV_write_cmos_sensor(0x3622, 0x01);

    OV5640YUV_write_cmos_sensor(0x3c04, 0x28);
    OV5640YUV_write_cmos_sensor(0x3c05, 0x98);
    OV5640YUV_write_cmos_sensor(0x3c06, 0x00);
    OV5640YUV_write_cmos_sensor(0x3c07, 0x08);
    OV5640YUV_write_cmos_sensor(0x3c08, 0x00);
    OV5640YUV_write_cmos_sensor(0x3c09, 0x1c);
    OV5640YUV_write_cmos_sensor(0x3c0a, 0x9c);
    OV5640YUV_write_cmos_sensor(0x3c0b, 0x40);

  //  OV5640YUV_write_cmos_sensor(0x3820, 0x47);
   // OV5640YUV_write_cmos_sensor(0x3821, 0x01);

    //dg add 2015-07-24 for stop flip & mirror image
    OV5640YUV_write_cmos_sensor(0x3820, 0x40);
    OV5640YUV_write_cmos_sensor(0x3821, 0x06);

    //windows setup
    OV5640YUV_write_cmos_sensor(0x3800, 0x00);
    OV5640YUV_write_cmos_sensor(0x3801, 0x00);
    OV5640YUV_write_cmos_sensor(0x3802, 0x00);
    OV5640YUV_write_cmos_sensor(0x3803, 0x04);

    //dg add  2015-07-25 to adjust X_AADR_END long for image windeos show
    OV5640YUV_write_cmos_sensor(0x3804, 0x0a);
    OV5640YUV_write_cmos_sensor(0x3805, 0x5f); //3f-5f->Good


    OV5640YUV_write_cmos_sensor(0x3806, 0x07);
    OV5640YUV_write_cmos_sensor(0x3807, 0x9b);
#if 1
    OV5640YUV_write_cmos_sensor(0x3808, 0x05);//1280
    OV5640YUV_write_cmos_sensor(0x3809, 0x00);

    OV5640YUV_write_cmos_sensor(0x380a, 0x03);//960
    OV5640YUV_write_cmos_sensor(0x380b, 0xc0);
#else
    OV5640YUV_write_cmos_sensor(0x3808, 0x05);
    OV5640YUV_write_cmos_sensor(0x3809, 0x80);
    OV5640YUV_write_cmos_sensor(0x380a, 0x01);
    OV5640YUV_write_cmos_sensor(0x380b, 0xe0);

#endif



    //OV5640YUV_write_cmos_sensor(0x3810, 0x00);
   // OV5640YUV_write_cmos_sensor(0x3811, 0x10);

    //dg add  2015-07-25 to adjust X OFFSET position coordinate for image windeos show
    OV5640YUV_write_cmos_sensor(0x3810, 0x00); // 00->01->00
    OV5640YUV_write_cmos_sensor(0x3811, 0xED); // 10->00->F0->EF->EE->ED->Good

    OV5640YUV_write_cmos_sensor(0x3812, 0x00);
    OV5640YUV_write_cmos_sensor(0x3813, 0x06);
    OV5640YUV_write_cmos_sensor(0x3814, 0x31);
    OV5640YUV_write_cmos_sensor(0x3815, 0x31);


    OV5640YUV_write_cmos_sensor(0x3034, 0x1a);
    OV5640YUV_write_cmos_sensor(0x3035, 0x21); //15fps
    OV5640YUV_write_cmos_sensor(0x3036, 0x46);
    OV5640YUV_write_cmos_sensor(0x3037, 0x13);
    OV5640YUV_write_cmos_sensor(0x3038, 0x00);
    OV5640YUV_write_cmos_sensor(0x3039, 0x00);

    OV5640YUV_write_cmos_sensor(0x380c, 0x07);
    OV5640YUV_write_cmos_sensor(0x380d, 0x68);
    OV5640YUV_write_cmos_sensor(0x380e, 0x03); //03
    OV5640YUV_write_cmos_sensor(0x380f, 0xd8); //d8

    OV5640YUV_write_cmos_sensor(0x3c01, 0xb4);
    OV5640YUV_write_cmos_sensor(0x3c00, 0x04);
    OV5640YUV_write_cmos_sensor(0x3a08, 0x00);
    OV5640YUV_write_cmos_sensor(0x3a09, 0x93);
    OV5640YUV_write_cmos_sensor(0x3a0e, 0x06);
    OV5640YUV_write_cmos_sensor(0x3a0a, 0x00);
    OV5640YUV_write_cmos_sensor(0x3a0b, 0x7b);
    OV5640YUV_write_cmos_sensor(0x3a0d, 0x08);

    OV5640YUV_write_cmos_sensor(0x3a00, 0x38); //25fps-20fps
    OV5640YUV_write_cmos_sensor(0x3a02, 0x03);
    OV5640YUV_write_cmos_sensor(0x3a03, 0xd8);
    OV5640YUV_write_cmos_sensor(0x3a14, 0x03);
    OV5640YUV_write_cmos_sensor(0x3a15, 0xd8);

    OV5640YUV_write_cmos_sensor(0x3618, 0x00);
    OV5640YUV_write_cmos_sensor(0x3612, 0x29);
    OV5640YUV_write_cmos_sensor(0x3708, 0x64);
    OV5640YUV_write_cmos_sensor(0x3709, 0x52);
    OV5640YUV_write_cmos_sensor(0x370c, 0x03);

    OV5640YUV_write_cmos_sensor(0x4001, 0x02);
    OV5640YUV_write_cmos_sensor(0x4004, 0x02);
    OV5640YUV_write_cmos_sensor(0x3000, 0x00);
    OV5640YUV_write_cmos_sensor(0x3002, 0x1c);
    OV5640YUV_write_cmos_sensor(0x3004, 0xff);
    OV5640YUV_write_cmos_sensor(0x3006, 0xc3);
    OV5640YUV_write_cmos_sensor(0x300e, 0x58);
    OV5640YUV_write_cmos_sensor(0x302e, 0x00);

     OV5640YUV_write_cmos_sensor(0x4300, 0x30);
    // OV5640YUV_write_cmos_sensor(0x4300, 0x32); //dg changge from 0x30->0x32

    OV5640YUV_write_cmos_sensor(0x501f, 0x00);
    OV5640YUV_write_cmos_sensor(0x4713, 0x03);
    OV5640YUV_write_cmos_sensor(0x4407, 0x04);
    OV5640YUV_write_cmos_sensor(0x460b, 0x35);
    OV5640YUV_write_cmos_sensor(0x460c, 0x22);//add by bright
    OV5640YUV_write_cmos_sensor(0x3824, 0x01);//add by bright
    OV5640YUV_write_cmos_sensor(0x5001, 0xa3);

    OV5640YUV_write_cmos_sensor(0x3406, 0x01);//awbinit
    OV5640YUV_write_cmos_sensor(0x3400, 0x06);
    OV5640YUV_write_cmos_sensor(0x3401, 0x80);
    OV5640YUV_write_cmos_sensor(0x3402, 0x04);
    OV5640YUV_write_cmos_sensor(0x3403, 0x00);
    OV5640YUV_write_cmos_sensor(0x3404, 0x06);
    OV5640YUV_write_cmos_sensor(0x3405, 0x00);
    //awb
    OV5640YUV_write_cmos_sensor(0x5180, 0xff);
    OV5640YUV_write_cmos_sensor(0x5181, 0xf2);
    OV5640YUV_write_cmos_sensor(0x5182, 0x00);
    OV5640YUV_write_cmos_sensor(0x5183, 0x14);
    OV5640YUV_write_cmos_sensor(0x5184, 0x25);
    OV5640YUV_write_cmos_sensor(0x5185, 0x24);
    OV5640YUV_write_cmos_sensor(0x5186, 0x16);
    OV5640YUV_write_cmos_sensor(0x5187, 0x16);
    OV5640YUV_write_cmos_sensor(0x5188, 0x16);
    OV5640YUV_write_cmos_sensor(0x5189, 0x72);
    OV5640YUV_write_cmos_sensor(0x518a, 0x68);
    OV5640YUV_write_cmos_sensor(0x518b, 0xf0);
    OV5640YUV_write_cmos_sensor(0x518c, 0xb2);
    OV5640YUV_write_cmos_sensor(0x518d, 0x50);
    OV5640YUV_write_cmos_sensor(0x518e, 0x30);
    OV5640YUV_write_cmos_sensor(0x518f, 0x30);
    OV5640YUV_write_cmos_sensor(0x5190, 0x50);
    OV5640YUV_write_cmos_sensor(0x5191, 0xf8);
    OV5640YUV_write_cmos_sensor(0x5192, 0x04);
    OV5640YUV_write_cmos_sensor(0x5193, 0x70);
    OV5640YUV_write_cmos_sensor(0x5194, 0xf0);
    OV5640YUV_write_cmos_sensor(0x5195, 0xf0);
    OV5640YUV_write_cmos_sensor(0x5196, 0x03);
    OV5640YUV_write_cmos_sensor(0x5197, 0x01);
    OV5640YUV_write_cmos_sensor(0x5198, 0x04);
    OV5640YUV_write_cmos_sensor(0x5199, 0x12);
    OV5640YUV_write_cmos_sensor(0x519a, 0x04);
    OV5640YUV_write_cmos_sensor(0x519b, 0x00);
    OV5640YUV_write_cmos_sensor(0x519c, 0x06);
    OV5640YUV_write_cmos_sensor(0x519d, 0x82);
    OV5640YUV_write_cmos_sensor(0x519e, 0x38);
    //color matrix
    OV5640YUV_write_cmos_sensor(0x5381, 0x1e);
    OV5640YUV_write_cmos_sensor(0x5382, 0x5b);
    OV5640YUV_write_cmos_sensor(0x5383, 0x14);
    OV5640YUV_write_cmos_sensor(0x5384, 0x06);
    OV5640YUV_write_cmos_sensor(0x5385, 0x82);
    OV5640YUV_write_cmos_sensor(0x5386, 0x88);
    OV5640YUV_write_cmos_sensor(0x5387, 0x7c);
    OV5640YUV_write_cmos_sensor(0x5388, 0x60);
    OV5640YUV_write_cmos_sensor(0x5389, 0x1c);
    OV5640YUV_write_cmos_sensor(0x538a, 0x01);
    OV5640YUV_write_cmos_sensor(0x538b, 0x98);
    //sharp&noise
    OV5640YUV_write_cmos_sensor(0x5300, 0x08);
    OV5640YUV_write_cmos_sensor(0x5301, 0x30);
    OV5640YUV_write_cmos_sensor(0x5302, 0x3f);
    OV5640YUV_write_cmos_sensor(0x5303, 0x10);
    OV5640YUV_write_cmos_sensor(0x5304, 0x08);
    OV5640YUV_write_cmos_sensor(0x5305, 0x30);
    OV5640YUV_write_cmos_sensor(0x5306, 0x18);
    OV5640YUV_write_cmos_sensor(0x5307, 0x28);
    OV5640YUV_write_cmos_sensor(0x5309, 0x08);
    OV5640YUV_write_cmos_sensor(0x530a, 0x30);
    OV5640YUV_write_cmos_sensor(0x530b, 0x04);
    OV5640YUV_write_cmos_sensor(0x530c, 0x06);
    //gamma
    OV5640YUV_write_cmos_sensor(0x5480, 0x01);
    OV5640YUV_write_cmos_sensor(0x5481, 0x06);
    OV5640YUV_write_cmos_sensor(0x5482, 0x12);
    OV5640YUV_write_cmos_sensor(0x5483, 0x1e);
    OV5640YUV_write_cmos_sensor(0x5484, 0x4a);
    OV5640YUV_write_cmos_sensor(0x5485, 0x58);
    OV5640YUV_write_cmos_sensor(0x5486, 0x65);
    OV5640YUV_write_cmos_sensor(0x5487, 0x72);
    OV5640YUV_write_cmos_sensor(0x5488, 0x7d);
    OV5640YUV_write_cmos_sensor(0x5489, 0x88);
    OV5640YUV_write_cmos_sensor(0x548a, 0x92);
    OV5640YUV_write_cmos_sensor(0x548b, 0xa3);
    OV5640YUV_write_cmos_sensor(0x548c, 0xb2);
    OV5640YUV_write_cmos_sensor(0x548d, 0xc8);
    OV5640YUV_write_cmos_sensor(0x548e, 0xdd);
    OV5640YUV_write_cmos_sensor(0x548f, 0xf0);
    OV5640YUV_write_cmos_sensor(0x5490, 0x15);
    //UV adjust
    OV5640YUV_write_cmos_sensor(0x5580, 0x06);
    OV5640YUV_write_cmos_sensor(0x5583, 0x40);
    OV5640YUV_write_cmos_sensor(0x5584, 0x10);
    OV5640YUV_write_cmos_sensor(0x5589, 0x10);
    OV5640YUV_write_cmos_sensor(0x558a, 0x00);
    OV5640YUV_write_cmos_sensor(0x558b, 0xf8);
    //lens shading
    OV5640YUV_write_cmos_sensor(0x5000, 0xa7);
    OV5640YUV_write_cmos_sensor(0x5800, 0x20);
    OV5640YUV_write_cmos_sensor(0x5801, 0x19);
    OV5640YUV_write_cmos_sensor(0x5802, 0x17);
    OV5640YUV_write_cmos_sensor(0x5803, 0x16);
    OV5640YUV_write_cmos_sensor(0x5804, 0x18);
    OV5640YUV_write_cmos_sensor(0x5805, 0x21);
    OV5640YUV_write_cmos_sensor(0x5806, 0x0F);
    OV5640YUV_write_cmos_sensor(0x5807, 0x0A);
    OV5640YUV_write_cmos_sensor(0x5808, 0x07);
    OV5640YUV_write_cmos_sensor(0x5809, 0x07);
    OV5640YUV_write_cmos_sensor(0x580a, 0x0A);
    OV5640YUV_write_cmos_sensor(0x580b, 0x0C);
    OV5640YUV_write_cmos_sensor(0x580c, 0x0A);
    OV5640YUV_write_cmos_sensor(0x580d, 0x03);
    OV5640YUV_write_cmos_sensor(0x580e, 0x01);
    OV5640YUV_write_cmos_sensor(0x580f, 0x01);
    OV5640YUV_write_cmos_sensor(0x5810, 0x03);
    OV5640YUV_write_cmos_sensor(0x5811, 0x09);
    OV5640YUV_write_cmos_sensor(0x5812, 0x0A);
    OV5640YUV_write_cmos_sensor(0x5813, 0x03);
    OV5640YUV_write_cmos_sensor(0x5814, 0x01);
    OV5640YUV_write_cmos_sensor(0x5815, 0x01);
    OV5640YUV_write_cmos_sensor(0x5816, 0x03);
    OV5640YUV_write_cmos_sensor(0x5817, 0x08);
    OV5640YUV_write_cmos_sensor(0x5818, 0x10);
    OV5640YUV_write_cmos_sensor(0x5819, 0x0A);
    OV5640YUV_write_cmos_sensor(0x581a, 0x06);
    OV5640YUV_write_cmos_sensor(0x581b, 0x06);
    OV5640YUV_write_cmos_sensor(0x581c, 0x08);
    OV5640YUV_write_cmos_sensor(0x581d, 0x0E);
    OV5640YUV_write_cmos_sensor(0x581e, 0x22);
    OV5640YUV_write_cmos_sensor(0x581f, 0x18);
    OV5640YUV_write_cmos_sensor(0x5820, 0x13);
    OV5640YUV_write_cmos_sensor(0x5821, 0x12);
    OV5640YUV_write_cmos_sensor(0x5822, 0x16);
    OV5640YUV_write_cmos_sensor(0x5823, 0x1E);
    OV5640YUV_write_cmos_sensor(0x5824, 0x64);
    OV5640YUV_write_cmos_sensor(0x5825, 0x2A);
    OV5640YUV_write_cmos_sensor(0x5826, 0x2C);
    OV5640YUV_write_cmos_sensor(0x5827, 0x2A);
    OV5640YUV_write_cmos_sensor(0x5828, 0x46);
    OV5640YUV_write_cmos_sensor(0x5829, 0x2A);
    OV5640YUV_write_cmos_sensor(0x582a, 0x26);
    OV5640YUV_write_cmos_sensor(0x582b, 0x24);
    OV5640YUV_write_cmos_sensor(0x582c, 0x26);
    OV5640YUV_write_cmos_sensor(0x582d, 0x2A);
    OV5640YUV_write_cmos_sensor(0x582e, 0x28);
    OV5640YUV_write_cmos_sensor(0x582f, 0x42);
    OV5640YUV_write_cmos_sensor(0x5830, 0x40);
    OV5640YUV_write_cmos_sensor(0x5831, 0x42);
    OV5640YUV_write_cmos_sensor(0x5832, 0x08);
    OV5640YUV_write_cmos_sensor(0x5833, 0x28);
    OV5640YUV_write_cmos_sensor(0x5834, 0x26);
    OV5640YUV_write_cmos_sensor(0x5835, 0x24);
    OV5640YUV_write_cmos_sensor(0x5836, 0x26);
    OV5640YUV_write_cmos_sensor(0x5837, 0x2A);
    OV5640YUV_write_cmos_sensor(0x5838, 0x44);
    OV5640YUV_write_cmos_sensor(0x5839, 0x4A);
    OV5640YUV_write_cmos_sensor(0x583a, 0x2C);
    OV5640YUV_write_cmos_sensor(0x583b, 0x2a);
    OV5640YUV_write_cmos_sensor(0x583c, 0x46);
    OV5640YUV_write_cmos_sensor(0x583d, 0xCE);

    OV5640YUV_write_cmos_sensor(0x5688, 0x22);
    OV5640YUV_write_cmos_sensor(0x5689, 0x22);
    OV5640YUV_write_cmos_sensor(0x568a, 0x42);
    OV5640YUV_write_cmos_sensor(0x568b, 0x24);
    OV5640YUV_write_cmos_sensor(0x568c, 0x42);
    OV5640YUV_write_cmos_sensor(0x568d, 0x24);
    OV5640YUV_write_cmos_sensor(0x568e, 0x22);
    OV5640YUV_write_cmos_sensor(0x568f, 0x22);

    OV5640YUV_write_cmos_sensor(0x5025, 0x00);

    OV5640YUV_write_cmos_sensor(0x3a0f, 0x30);
    OV5640YUV_write_cmos_sensor(0x3a10, 0x28);
    OV5640YUV_write_cmos_sensor(0x3a1b, 0x30);
    OV5640YUV_write_cmos_sensor(0x3a1e, 0x28);
    OV5640YUV_write_cmos_sensor(0x3a11, 0x61);
    OV5640YUV_write_cmos_sensor(0x3a1f, 0x10);

    OV5640YUV_write_cmos_sensor(0x4005, 0x1a);
    OV5640YUV_write_cmos_sensor(0x3406, 0x00);//awbinit
    OV5640YUV_write_cmos_sensor(0x3503, 0x00);//awbinit
    OV5640YUV_write_cmos_sensor(0x3008, 0x02);
}


//set constant focus
static void OV5640_FOCUS_AD5820_Constant_Focus(void)
{
    UINT8 state = 0x8F;
    UINT32 iteration = 300;

    //send constant focus mode command to firmware
    OV5640YUV_write_cmos_sensor(0x3023,0x01);
    OV5640YUV_write_cmos_sensor(0x3022,0x04);
    return;
}


static void OV5640_FOCUS_AD5820_Single_Focus()
{

    UINT8 state = 0x8F;
    UINT32 iteration = 100;
    OV5640YUV_write_cmos_sensor(0x3023,0x01);
    OV5640YUV_write_cmos_sensor(0x3022,0x03);

    iteration = 100;
    do{
        state = (UINT8)OV5640YUV_read_cmos_sensor(0x3023);

        if(state == 0x00)
        {
            SENSORDB("single focused!\n");
            break;
        }
     //   mdelay(30);

         mdelay(3);

        iteration --;

    }while(iteration);

    return;
}

static void OV5640_FOCUS_AD5820_Pause_Focus()
{
    UINT8 state = 0x8F;
    UINT32 iteration = 100;

    //send idle command to firmware
    OV5640YUV_write_cmos_sensor(0x3023,0x01);
    OV5640YUV_write_cmos_sensor(0x3022,0x06);

    iteration = 100;
    do{
        state = (UINT8)OV5640YUV_read_cmos_sensor(0x3023);

        if(state == 0x00)
        {
            break;
        }
        msleep(30);
    //      msleep(10);

        iteration --;

    }while(iteration);

    if(iteration==0)
    {
        printk("pause focus fail.........state is 0x%x...",state);

       return ;

    }

    printk("pause focus  OK ......");

}
static void OV5640_FOCUS_AD5820_Cancel_Focus()
{

    UINT8 state = 0x8F;
    UINT32 iteration = 100;

    //send idle command to firmware
    OV5640YUV_write_cmos_sensor(0x3023,0x01);
    OV5640YUV_write_cmos_sensor(0x3022,0x08);

    iteration = 100;
    do{
        state = (UINT8)OV5640YUV_read_cmos_sensor(0x3023);
        if(state == 0x00)
        {
            break;
        }
        msleep(30);
        iteration --;

    }while(iteration);

}

void OV5640YUV_set_720P_init(void)
{
    //OV5640YUV_write_cmos_sensor(0x3008, 0x42);

    OV5640YUV_write_cmos_sensor(0x5189, 0x72);

    OV5640YUV_write_cmos_sensor(0x3503, 0x00);//AE
    //OV5640YUV_write_cmos_sensor(0x3406, 0x00);//AWB
    OV5640YUV_write_cmos_sensor(0x3a00, 0x38);//enable night

    OV5640YUV_write_cmos_sensor(0x5302, 0x20);
    OV5640YUV_write_cmos_sensor(0x5303, 0x08);
    OV5640YUV_write_cmos_sensor(0x5306, 0x10);//18
    OV5640YUV_write_cmos_sensor(0x5307, 0x20);//28

    //OV5640YUV_write_cmos_sensor(0x3820, 0x47);
   // OV5640YUV_write_cmos_sensor(0x3821, 0x01);

    //dg add 2015-07-24 for stop flip image
    OV5640YUV_write_cmos_sensor(0x3820, 0x40);
    OV5640YUV_write_cmos_sensor(0x3821, 0x06);

    OV5640YUV_write_cmos_sensor(0x3108, 0x01);


    //windows setup
    OV5640YUV_write_cmos_sensor(0x3800, 0x00);
    OV5640YUV_write_cmos_sensor(0x3801, 0x00);
    OV5640YUV_write_cmos_sensor(0x3802, 0x00);
    OV5640YUV_write_cmos_sensor(0x3803, 0x04);

    //dg add  2015-07-25 to adjust X_AADR_END long for image windeos show
    OV5640YUV_write_cmos_sensor(0x3804, 0x0a);
    OV5640YUV_write_cmos_sensor(0x3805, 0x5f); //3f-5f->Good


    OV5640YUV_write_cmos_sensor(0x3806, 0x07);
    OV5640YUV_write_cmos_sensor(0x3807, 0x9b);
#if 1
    OV5640YUV_write_cmos_sensor(0x3808, 0x05);//1280
    OV5640YUV_write_cmos_sensor(0x3809, 0x00);

    OV5640YUV_write_cmos_sensor(0x380a, 0x03);//960
    OV5640YUV_write_cmos_sensor(0x380b, 0xc0);
#else
    OV5640YUV_write_cmos_sensor(0x3808, 0x05);
    OV5640YUV_write_cmos_sensor(0x3809, 0x80);
    OV5640YUV_write_cmos_sensor(0x380a, 0x01);
    OV5640YUV_write_cmos_sensor(0x380b, 0xe0);

#endif



    //OV5640YUV_write_cmos_sensor(0x3810, 0x00);
   // OV5640YUV_write_cmos_sensor(0x3811, 0x10);

    //dg add  2015-07-25 to adjust X OFFSET position coordinate for image windeos show
    OV5640YUV_write_cmos_sensor(0x3810, 0x00); // 00->01->00
    OV5640YUV_write_cmos_sensor(0x3811, 0xED); // 10->00->F0->EF->EE->ED->Good

    OV5640YUV_write_cmos_sensor(0x3812, 0x00);
    OV5640YUV_write_cmos_sensor(0x3813, 0x06);
    OV5640YUV_write_cmos_sensor(0x3814, 0x31);
    OV5640YUV_write_cmos_sensor(0x3815, 0x31);




    OV5640YUV_write_cmos_sensor(0x3034, 0x1a);
    OV5640YUV_write_cmos_sensor(0x3035, 0x21); //25fps
    OV5640YUV_write_cmos_sensor(0x3036, 0x46);
    OV5640YUV_write_cmos_sensor(0x3037, 0x13);
    OV5640YUV_write_cmos_sensor(0x3038, 0x00);
    OV5640YUV_write_cmos_sensor(0x3039, 0x00);

    OV5640YUV_write_cmos_sensor(0x380c, 0x07);
    OV5640YUV_write_cmos_sensor(0x380d, 0x68);
    OV5640YUV_write_cmos_sensor(0x380e, 0x03);
    OV5640YUV_write_cmos_sensor(0x380f, 0xd8);

    OV5640YUV_write_cmos_sensor(0x3a08, 0x00);
    OV5640YUV_write_cmos_sensor(0x3a09, 0x93);
    OV5640YUV_write_cmos_sensor(0x3a0e, 0x06);
    OV5640YUV_write_cmos_sensor(0x3a0a, 0x00);
    OV5640YUV_write_cmos_sensor(0x3a0b, 0x7b);
    OV5640YUV_write_cmos_sensor(0x3a0d, 0x08);

    OV5640YUV_write_cmos_sensor(0x3618, 0x00);
    OV5640YUV_write_cmos_sensor(0x3612, 0x29);
    OV5640YUV_write_cmos_sensor(0x3709, 0x52);
    OV5640YUV_write_cmos_sensor(0x370c, 0x03);

    OV5640YUV_write_cmos_sensor(0x4004, 0x02);
    OV5640YUV_write_cmos_sensor(0x460b, 0x35);
    OV5640YUV_write_cmos_sensor(0x460c, 0x22);
    OV5640YUV_write_cmos_sensor(0x4837, 0x15);
    OV5640YUV_write_cmos_sensor(0x3824, 0x01);
    OV5640YUV_write_cmos_sensor(0x5001, 0xa3);

    //OV5640YUV_write_cmos_sensor(0x3008, 0x02);
}

void OV5640YUV_set_5M_init(void)
{
    //OV5640YUV_write_cmos_sensor(0x3008, 0x42);

    OV5640YUV_write_cmos_sensor(0x5189, 0x66);

    OV5640YUV_write_cmos_sensor(0x3503, 0x07);//AE
    //OV5640YUV_write_cmos_sensor(0x3406, 0x01);//AWB
    OV5640YUV_write_cmos_sensor(0x3a00, 0x38);//disable night

    OV5640YUV_write_cmos_sensor(0x5302, 0x30);
    OV5640YUV_write_cmos_sensor(0x5303, 0x10);
    OV5640YUV_write_cmos_sensor(0x5306, 0x08);
    OV5640YUV_write_cmos_sensor(0x5307, 0x18);

    OV5640YUV_write_cmos_sensor(0x3820, 0x40); //46
    OV5640YUV_write_cmos_sensor(0x3821, 0x06); //00

    OV5640YUV_write_cmos_sensor(0x3800, 0x00);
    OV5640YUV_write_cmos_sensor(0x3801, 0x00);
    OV5640YUV_write_cmos_sensor(0x3802, 0x00);
    OV5640YUV_write_cmos_sensor(0x3803, 0x00);
    OV5640YUV_write_cmos_sensor(0x3804, 0x0a);
    OV5640YUV_write_cmos_sensor(0x3805, 0x3f);
    OV5640YUV_write_cmos_sensor(0x3806, 0x07);
    OV5640YUV_write_cmos_sensor(0x3807, 0x9f);
    OV5640YUV_write_cmos_sensor(0x3808, 0x0a);
    OV5640YUV_write_cmos_sensor(0x3809, 0x20);
    OV5640YUV_write_cmos_sensor(0x380a, 0x07);
    OV5640YUV_write_cmos_sensor(0x380b, 0x98);
    OV5640YUV_write_cmos_sensor(0x3810, 0x00);
    OV5640YUV_write_cmos_sensor(0x3811, 0x10);
    OV5640YUV_write_cmos_sensor(0x3812, 0x00);
    OV5640YUV_write_cmos_sensor(0x3813, 0x04);
    OV5640YUV_write_cmos_sensor(0x3814, 0x11);
    OV5640YUV_write_cmos_sensor(0x3815, 0x11);

    OV5640YUV_write_cmos_sensor(0x3034, 0x1a);
    OV5640YUV_write_cmos_sensor(0x3035, 0x11); //10fps
    OV5640YUV_write_cmos_sensor(0x3036, 0x46);
    OV5640YUV_write_cmos_sensor(0x3037, 0x13);
    OV5640YUV_write_cmos_sensor(0x3038, 0x00);
    OV5640YUV_write_cmos_sensor(0x3039, 0x00);

    OV5640YUV_write_cmos_sensor(0x380c, 0x0b);
    OV5640YUV_write_cmos_sensor(0x380d, 0x1c);
    OV5640YUV_write_cmos_sensor(0x380e, 0x07);
    OV5640YUV_write_cmos_sensor(0x380f, 0xb0);

    OV5640YUV_write_cmos_sensor(0x3a08, 0x00);
    OV5640YUV_write_cmos_sensor(0x3a09, 0xc5);
    OV5640YUV_write_cmos_sensor(0x3a0e, 0x0a);
    OV5640YUV_write_cmos_sensor(0x3a0a, 0x00);
    OV5640YUV_write_cmos_sensor(0x3a0b, 0xa4);
    OV5640YUV_write_cmos_sensor(0x3a0d, 0x0c);

    OV5640YUV_write_cmos_sensor(0x3618, 0x04);
    OV5640YUV_write_cmos_sensor(0x3612, 0x2b);
    OV5640YUV_write_cmos_sensor(0x3709, 0x12);
    OV5640YUV_write_cmos_sensor(0x370c, 0x00);

    OV5640YUV_write_cmos_sensor(0x4004, 0x06);
    OV5640YUV_write_cmos_sensor(0x3002, 0x00);
    OV5640YUV_write_cmos_sensor(0x3006, 0xff);
    OV5640YUV_write_cmos_sensor(0x4713, 0x02);
    OV5640YUV_write_cmos_sensor(0x4407, 0x04);
    OV5640YUV_write_cmos_sensor(0x460b, 0x37);
    OV5640YUV_write_cmos_sensor(0x460c, 0x22);
    OV5640YUV_write_cmos_sensor(0x4837, 0x16);
    OV5640YUV_write_cmos_sensor(0x3824, 0x01);
    OV5640YUV_write_cmos_sensor(0x5001, 0x83);

    //OV5640YUV_write_cmos_sensor(0x3008, 0x02);
    mdelay(300);//liuxinming
}


void OV5640YUV_set_720P(void)
{
    SENSORDB("OV5640YUV_set_720P Start \n");
    OV5640YUV_g_RES = OV5640_720P;
    OV5640YUV_set_720P_init();
    OV5640YUV_PV_pclk = 5600;
    OV5640YUV_sensor_pclk=56000000;
    SENSORDB("Set 720P End\n");
}


void OV5640YUV_set_5M(void)
{
    SENSORDB("Set 5M begin\n");
    OV5640YUV_g_RES = OV5640_5M;
    OV5640YUV_set_5M_init();
    OV5640YUV_CAP_pclk = 5600;
    OV5640YUV_sensor_pclk=56000000;
    SENSORDB("Set 5M End\n");
}


/*************************************************************************
* FUNCTION
*   OV5640_night_mode
*
* DESCRIPTION
*   This function night mode of OV5640.
*
* PARAMETERS
*   none
*
* RETURNS
*   None
*
* GLOBALS AFFECTED
*
*************************************************************************/
void OV5640YUV_NightMode(bool bEnable)
{
    if(bEnable)
    {
        OV5640YUV_night_mode = true;

        if(OV5640YUV_MPEG4_encode_mode== true)
        {
            OV5640YUV_write_cmos_sensor(0x3034, 0x1a);
            OV5640YUV_write_cmos_sensor(0x3035, 0x21); //10fps
            OV5640YUV_write_cmos_sensor(0x3036, 0x46);
            OV5640YUV_write_cmos_sensor(0x3037, 0x13);
            OV5640YUV_write_cmos_sensor(0x3038, 0x00);
            OV5640YUV_write_cmos_sensor(0x3039, 0x00);

            OV5640YUV_write_cmos_sensor(0x380c, 0x07);
            OV5640YUV_write_cmos_sensor(0x380d, 0x68);
            OV5640YUV_write_cmos_sensor(0x380e, 0x05);
            OV5640YUV_write_cmos_sensor(0x380f, 0xc4);

            OV5640YUV_write_cmos_sensor(0x3c01, 0xb4);
            OV5640YUV_write_cmos_sensor(0x3c00, 0x04);
            OV5640YUV_write_cmos_sensor(0x3a08, 0x00);
            OV5640YUV_write_cmos_sensor(0x3a09, 0x93);
            OV5640YUV_write_cmos_sensor(0x3a0e, 0x0a);
            OV5640YUV_write_cmos_sensor(0x3a0a, 0x00);
            OV5640YUV_write_cmos_sensor(0x3a0b, 0x7b);
            OV5640YUV_write_cmos_sensor(0x3a0d, 0x0c);

            OV5640YUV_write_cmos_sensor(0x3a00, 0x38);
            OV5640YUV_write_cmos_sensor(0x3a02 ,0x05);
            OV5640YUV_write_cmos_sensor(0x3a03 ,0xc4);
            OV5640YUV_write_cmos_sensor(0x3a14 ,0x05);
            OV5640YUV_write_cmos_sensor(0x3a15 ,0xc4);



        }
        else
        {
            OV5640YUV_write_cmos_sensor(0x3a00, 0x3c);//25fps-5fps
            OV5640YUV_write_cmos_sensor(0x3a02 ,0x0b);
            OV5640YUV_write_cmos_sensor(0x3a03 ,0x88);
            OV5640YUV_write_cmos_sensor(0x3a14 ,0x0b);
            OV5640YUV_write_cmos_sensor(0x3a15 ,0x88);
        }
    }
    else
    {
        OV5640YUV_night_mode = false;

        if(OV5640YUV_MPEG4_encode_mode==false)
        {
            OV5640YUV_write_cmos_sensor(0x3034, 0x1a);
            OV5640YUV_write_cmos_sensor(0x3035, 0x21); //15fps
            OV5640YUV_write_cmos_sensor(0x3036, 0x46);
            OV5640YUV_write_cmos_sensor(0x3037, 0x13);
            OV5640YUV_write_cmos_sensor(0x3038, 0x00);
            OV5640YUV_write_cmos_sensor(0x3039, 0x00);

            OV5640YUV_write_cmos_sensor(0x380c, 0x07);
            OV5640YUV_write_cmos_sensor(0x380d, 0x68);
            OV5640YUV_write_cmos_sensor(0x380e, 0x03);
            OV5640YUV_write_cmos_sensor(0x380f, 0xd8);

            OV5640YUV_write_cmos_sensor(0x3c01, 0xb4);
            OV5640YUV_write_cmos_sensor(0x3c00, 0x04);
            OV5640YUV_write_cmos_sensor(0x3a08, 0x00);
            OV5640YUV_write_cmos_sensor(0x3a09, 0x93);
            OV5640YUV_write_cmos_sensor(0x3a0e, 0x06);
            OV5640YUV_write_cmos_sensor(0x3a0a, 0x00);
            OV5640YUV_write_cmos_sensor(0x3a0b, 0x7b);
            OV5640YUV_write_cmos_sensor(0x3a0d, 0x08);

            OV5640YUV_write_cmos_sensor(0x3a00, 0x38);
            OV5640YUV_write_cmos_sensor(0x3a02 ,0x03);
            OV5640YUV_write_cmos_sensor(0x3a03 ,0xd8);
            OV5640YUV_write_cmos_sensor(0x3a14 ,0x03);
            OV5640YUV_write_cmos_sensor(0x3a15 ,0xd8);
        }
        else
        {
            OV5640YUV_write_cmos_sensor(0x3a00, 0x38);//25fps-20fps
            OV5640YUV_write_cmos_sensor(0x3a02 ,0x03);
            OV5640YUV_write_cmos_sensor(0x3a03 ,0xd8);
            OV5640YUV_write_cmos_sensor(0x3a14 ,0x03);
            OV5640YUV_write_cmos_sensor(0x3a15 ,0xd8);
        }
    }
}

static void OV5640YUV_SetDummy(const kal_uint16 iPixels, const kal_uint16 iLines)
{
   return ;
}


static void OV5640YUV_set_AE_mode(kal_bool AE_enable)
{
    kal_uint8 temp_AE_reg = 0;

    if (AE_enable == KAL_TRUE)
    {
        OV5640YUV_write_cmos_sensor(0x3503, 0x00);
    }
    else
    {
        OV5640YUV_write_cmos_sensor(0x3503, 0x07);
    }
}

#if 0
static void OV5640YUV_set_AWB_mode(kal_bool AWB_enable)
{
    kal_uint8 temp_AWB_reg = 0;

    if (AWB_enable == KAL_TRUE)
    {
        OV5640YUV_write_cmos_sensor(0x3406, 0x00);
    }
    else
    {
        OV5640YUV_write_cmos_sensor(0x3406, 0x01);
    }
}
#endif
/*************************************************************************
* FUNCTION
*    OV5640YUV_SetGain
*
* DESCRIPTION
*    This function is to set global gain to sensor.
*
* PARAMETERS
*    gain : sensor global gain(base: 0x40)
*
* RETURNS
*    the actually gain set to sensor.
*
* GLOBALS AFFECTED
*
*************************************************************************/
//! Due to the OV5640 set gain will happen race condition.
//! It need to use a critical section to protect it.
//static atomic_t OV5640_SetGain_Flag;
//static wait_queue_head_t OV5640_SetGain_waitQueue;

void OV5640YUV_SetGain(UINT16 iGain)
{
    kal_uint8 iReg;
    int timeOut = 0;

#if 0
    if (atomic_read(&OV5640_SetGain_Flag) == 1) {
        timeOut = wait_event_interruptible_timeout(
                    OV5640_SetGain_waitQueue, atomic_read(&OV5640_SetGain_Flag) == 0, 1 * HZ);
        if (timeOut == 0) {
            SENSORDB("[OV5640YUV_SetGain] Set Gain Wait Queue time out \n");
            return;
        }
    }
    atomic_set(&OV5640_SetGain_Flag, 1);
#endif
    OV5640YUV_write_cmos_sensor(0x3212, 0x00);
    OV5640YUV_write_cmos_sensor(0x350B, (kal_uint32)iGain);
    OV5640YUV_write_cmos_sensor(0x3212, 0x10);
    OV5640YUV_write_cmos_sensor(0x3212, 0xA0);

#if 0
    atomic_set(&OV5640_SetGain_Flag, 0);
    wake_up_interruptible(&OV5640_SetGain_waitQueue);
#endif

}   /*  OV5640YUV_SetGain  */



/*************************************************************************
* FUNCTION
*   OV5640YUV_read_shutter
*
* DESCRIPTION
*   This function to  Get exposure time.
*
* PARAMETERS
*   None
*
* RETURNS
*   shutter : exposured lines
*
* GLOBALS AFFECTED
*
*************************************************************************/
UINT16 OV5640YUV_read_shutter(void)
{
    kal_uint8 temp_reg1, temp_reg2, temp_reg3;
    kal_uint16 temp_reg;
    temp_reg1 = OV5640YUV_read_cmos_sensor(0x3500);
    temp_reg2 = OV5640YUV_read_cmos_sensor(0x3501);
    temp_reg3 = OV5640YUV_read_cmos_sensor(0x3502);

    // SENSORDB("ov5640read shutter 0x3500=0x%x,0x3501=0x%x,0x3502=0x%x\n",
    //	temp_reg1,temp_reg2,temp_reg3);
    temp_reg = ((temp_reg1<<12) & 0xF000) | ((temp_reg2<<4) & 0x0FF0) | ((temp_reg3>>4) & 0x0F);
    //SENSORDB("ov5640read shutter = 0x%x\n", temp_reg);
    return (UINT16)temp_reg;
}

void OV5640YUV_write_shutter(kal_uint16 shutter)
{
    kal_uint16 iExp = shutter;
    kal_uint16 OV5640_g_iExtra_ExpLines = 0 ;
    int timeOut = 0;

    OV5640YUV_write_cmos_sensor(0x3500, (iExp >> 12) & 0xFF);
    OV5640YUV_write_cmos_sensor(0x3501, (iExp >> 4 ) & 0xFF);
    OV5640YUV_write_cmos_sensor(0x3502, (iExp <<4 ) & 0xFF);
}   /* write_OV5640_shutter */


/*************************************************************************
* FUNCTION
*   OV5640YUV_SetShutter
*
* DESCRIPTION
*   This function set e-shutter of OV5640 to change exposure time.
*
* PARAMETERS
*   shutter : exposured lines
*
* RETURNS
*   None
*
* GLOBALS AFFECTED
*
*************************************************************************/
void OV5640YUV_SetShutter(kal_uint16 iShutter)
{

    if (iShutter < 1)
        iShutter = 1;

    OV5640YUV_pv_exposure_lines = iShutter;
    OV5640YUV_write_shutter(iShutter);
    //SENSORDB("iShutter = %d\n", iShutter);

}   /*  OV5640YUV_SetShutter   */




/*************************************************************************
* FUNCTION
*    read_OV5640YUV_gain
*
* DESCRIPTION
*    This function is to set global gain to sensor.
*
* PARAMETERS
*    None
*
* RETURNS
*    gain : sensor global gain(base: 0x40)
*
* GLOBALS AFFECTED
*
*************************************************************************/
kal_uint16 read_OV5640YUV_gain(void)
{

    kal_uint8 temp_gain;
    kal_uint16 gain;

    gain = OV5640YUV_read_cmos_sensor(0x350B);

    return gain;
}  /* read_OV5640YUV_gain */

void write_OV5640YUV_gain(kal_uint16 gain)
{
    OV5640YUV_SetGain(gain);
}


/*************************************************************************
* FUNCTION
*   OV5640YUVPreview
*
* DESCRIPTION
*   This function start the sensor preview.
*
* PARAMETERS
*   *image_window : address pointer of pixel numbers in one period of HSYNC
*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
*
* RETURNS
*   None
*
* GLOBALS AFFECTED
*
*************************************************************************/
UINT32 OV5640YUVPreview()
{
 //   kal_uint16 iStartX = 0, iStartY = 0;

   g_iOV5640YUV_Mode = OV5640_MODE_PREVIEW;

    OV5640YUV_write_cmos_sensor(0x4202,0x0f);
   // msleep(30);

    msleep(5);

    OV5640YUV_set_720P();

    OV5640YUV_write_cmos_sensor(0x4202,0x00);
  //  msleep(30);


  // dg cancle  ,donot focus  start,otherwise picture is not working well.
   //dg  use after for autofocus on android4.4 version
    OV5640YUV_write_cmos_sensor(0x3023,0x01);
    OV5640YUV_write_cmos_sensor(0x3022,0x04);

#if 0
    if (tem){
        OV5640YUV_SetShutter(back_shutter);
        write_OV5640YUV_gain(back_pv_gain);
    }
    tem =0;
#endif

    //OV5640YUV_write_cmos_sensor(0x3820, 0x46);
    //OV5640YUV_write_cmos_sensor(0x3821, 0x00);
/*
    if(sensor_config_data->SensorOperationMode==MSDK_SENSOR_OPERATION_MODE_VIDEO)		// MPEG4 Encode Mode
    {
        OV5640YUV_MPEG4_encode_mode = KAL_TRUE;
    }
    else
    {
        OV5640YUV_MPEG4_encode_mode = KAL_FALSE;
    }

    iStartX += OV5640_IMAGE_SENSOR_PV_STARTX;
    iStartY += OV5640_IMAGE_SENSOR_PV_STARTY;
*/

    // sensor_config_data->SensorImageMirror = IMAGE_HV_MIRROR;
    // OV5640YUV_Set_Mirror_Flip(sensor_config_data->SensorImageMirror);
    /*************************************************************************************************************/

    //dg cancle 2015-07-18
    //OV5640YUV_write_cmos_sensor(0x3820,0x47);
    //OV5640YUV_write_cmos_sensor(0x3821,0x01);
   // OV5640YUV_write_cmos_sensor(0x4514,0x00);
    /*************************************************************************************************************/

#if 0
    OV5640YUV_dummy_pixels = 0;
    OV5640YUV_dummy_lines = 0;
    OV5640YUV_PV_dummy_pixels = OV5640YUV_dummy_pixels;
    OV5640YUV_PV_dummy_lines = OV5640YUV_dummy_lines;
    //OV5640YUV_SetDummy(OV5640YUV_dummy_pixels, OV5640YUV_dummy_lines);
#endif

    //OV5640YUV_NightMode(OV5640YUV_night_mode);
    OV5640YUV_NightMode(false);

#if 0
    memcpy(&OV5640YUVSensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
    image_window->GrabStartX= iStartX;
    image_window->GrabStartY= iStartY;
    image_window->ExposureWindowWidth= OV5640_IMAGE_SENSOR_PV_WIDTH - 2*iStartX;
    image_window->ExposureWindowHeight= OV5640_IMAGE_SENSOR_PV_HEIGHT - 2*iStartY;
#endif
    return 0;
}



UINT32 OV5640YUVCapture( )
{
    kal_uint32 shutter = 0;
    kal_uint32 temp_shutter = 0;
    kal_uint16 iStartX = 0, iStartY = 0;
    kal_uint32 pv_gain = 0;
    kal_uint8 temp = 0;//for night mode


    if(g_iOV5640YUV_Mode == OV5640_MODE_PREVIEW)
    {
        g_iOV5640YUV_Mode = OV5640_MODE_CAPTURE;

      //  if(sensor_config_data->EnableShutterTansfer==KAL_TRUE)
         //   shutter=sensor_config_data->CaptureShutter;

        temp= OV5640YUV_read_cmos_sensor(0x3a00);
        OV5640YUV_write_cmos_sensor(0x3a00,temp&0xfb);

        OV5640YUV_set_AE_mode(KAL_FALSE);
        //OV5640YUV_set_AWB_mode(KAL_FALSE);

        shutter = OV5640YUV_read_shutter();

        pv_gain = read_OV5640YUV_gain();
        back_shutter = shutter;
        back_pv_gain = pv_gain;

        tem = 1;

        SENSORDB("Preview Shutter = %d, Gain = %d\n", shutter, pv_gain);

#if 0
        if ((image_window->ImageTargetWidth<= OV5640_IMAGE_SENSOR_PV_WIDTH) &&
                (image_window->ImageTargetHeight<= OV5640_IMAGE_SENSOR_PV_HEIGHT))
        {
            OV5640YUV_dummy_pixels= 0;
            OV5640YUV_dummy_lines = 0;
            iStartX = OV5640_IMAGE_SENSOR_PV_STARTX;
            iStartY = OV5640_IMAGE_SENSOR_PV_STARTY;
            image_window->GrabStartX=iStartX;
            image_window->GrabStartY=iStartY;
            image_window->ExposureWindowWidth=OV5640_IMAGE_SENSOR_PV_WIDTH - 2*iStartX;
            image_window->ExposureWindowHeight=OV5640_IMAGE_SENSOR_PV_HEIGHT- 2*iStartY;
        }
        else
        {
#endif
            OV5640_FOCUS_AD5820_Single_Focus();

            OV5640YUV_write_cmos_sensor(0x4202,0x0f);
            Sleep(30);
            OV5640YUV_set_5M();
            OV5640YUV_write_cmos_sensor(0x4202,0x00);
            Sleep(30);
#if 0
            OV5640YUV_dummy_pixels= 0;
            OV5640YUV_dummy_lines = 0;
            OV5640YUV_CAP_pclk = 560;
            OV5640YUV_PV_pclk = 560;

            //temp_shutter = (shutter*(OV5640_PV_PERIOD_PIXEL_NUMS_HTS+OV5640YUV_PV_dummy_pixels)*OV5640YUV_CAP_pclk)
            //			/(OV5640_FULL_PERIOD_PIXEL_NUMS_HTS+OV5640YUV_dummy_pixels)/OV5640YUV_PV_pclk;
            //shutter = (kal_uint32)(temp_shutter);

            shutter = shutter*4/3;

            SENSORDB("cap shutter calutaed = %d, 0x%x\n", shutter,shutter);
            iStartX = 2* OV5640_IMAGE_SENSOR_PV_STARTX;
            iStartY = 2* OV5640_IMAGE_SENSOR_PV_STARTY;
            image_window->GrabStartX=iStartX;
            image_window->GrabStartY=iStartY;
            image_window->ExposureWindowWidth=OV5640_IMAGE_SENSOR_FULL_WIDTH -2*iStartX;
            image_window->ExposureWindowHeight=OV5640_IMAGE_SENSOR_FULL_HEIGHT-2*iStartY;
        }

        sensor_config_data->Lines = image_window->ExposureWindowHeight;
        sensor_config_data->Shutter =shutter;

        OV5640YUV_SetDummy(OV5640YUV_dummy_pixels, OV5640YUV_dummy_lines);


#endif
        OV5640YUV_SetShutter(shutter);
        write_OV5640YUV_gain(pv_gain);
#if 0

        memcpy(&OV5640YUVSensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
#endif
        // sensor_config_data->SensorImageMirror = IMAGE_NORMAL;
        // OV5640YUV_Set_Mirror_Flip(sensor_config_data->SensorImageMirror);
    }

    /*************************************************************************************************************/
    OV5640YUV_write_cmos_sensor(0x3820,0x46);
    OV5640YUV_write_cmos_sensor(0x3821,0x00);
    OV5640YUV_write_cmos_sensor(0x4514,0x88);
    /*************************************************************************************************************/

    return ERROR_NONE;
}





/////////////////////////////////////////////////////////////////////////////////////////////////////////




/* default format */
#define QVGA_WIDTH  320
#define QVGA_HEIGHT	240

#define VGA_WIDTH	640
#define VGA_HEIGHT	480

#define XGA_WIDTH	1024
#define XGA_HEIGHT	768

#define SXGA_WIDTH	1280
#define SXGA_HEIGHT	960

#define UXGA_WIDTH	1600
#define UXGA_HEIGHT	1200

#define QXGA_WIDTH	2048
#define QXGA_HEIGHT	1536

#define QSXGA_WIDTH	    2560
#define QSXGA_HEIGHT	1920  //normally 2048, but ov5640 only support simple qsxga

#define CAPTURE_FRAME_RATE  500   /* multiplied by 100 */
#define PREVIEW_FRAME_RATE  1500   /* multiplied by 100 */

#define OV5640_COLUMN_SKIP 0
#define OV5640_ROW_SKIP    0
#define OV5640_MAX_WIDTH   (QSXGA_WIDTH)
#define OV5640_MAX_HEIGHT  (QSXGA_HEIGHT)

#define OV5640_HFLIP 0x1
#define OV5640_VFLIP 0x2


#define DEV_DBG_EN   	1
#define REG_ADDR_STEP 2
#define REG_DATA_STEP 1
#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)

#define csi_dev_err(x,arg...) printk(KERN_INFO"[OV5640]"x,##arg)
#define csi_dev_print(x,arg...) printk(KERN_INFO"[OV5640]"x,##arg)



enum ov5640_resolution {
    RESV_VGA = 1,
    RESV_XGA,
    RESV_SXGA,
    RESV_UXGA,
    RESV_QXGA,
    RESV_QSXGA,
};


struct regval {
    unsigned short reg;
    unsigned char  val;
};

struct regval_list {
    unsigned char reg_num[REG_ADDR_STEP];
    unsigned char value[REG_DATA_STEP];
};

#if 0
struct ov5640_color_format {
    enum v4l2_mbus_pixelcode code;
    enum v4l2_colorspace colorspace;
};

struct ov5640_win_size {
    char *name;
    enum ov5640_resolution resv;
    unsigned int  width;
    unsigned int  height;
    const struct regval *regs;
};


struct ov5640_priv {
    struct v4l2_subdev  subdev;
    const struct ov5640_color_format *cfmt;
    const struct ov5640_win_size *win;
    int  model;
    int brightness;
    int contrast;
    int saturation;
    int hue;
    int exposure;
    int sharpness;
    int colorfx;
    int flip_flag;

};
#endif

#if 1



/****************************************************************************************
 * structures
 */
struct ov5640_win_size {
    char                        *name;
    __u32                       width;
    __u32                       height;
    __u32                       exposure_line_width;
    __u32                       capture_maximum_shutter;
    const struct regval_list    *win_regs;
    const struct regval_list    *lsc_regs;
    unsigned int                *frame_rate_array;

     enum ov5640_resolution resv;
     const struct regval *regs;

};




struct ov5640_color_format {
    enum v4l2_mbus_pixelcode code;
    enum v4l2_colorspace colorspace;
};



typedef struct {
    unsigned int max_shutter;
    unsigned int shutter;
    unsigned int gain;
    unsigned int dummy_line;
    unsigned int dummy_pixel;
    unsigned int extra_line;
} exposure_param_t;

enum prev_capt {
    PREVIEW_MODE = 0,
    CAPTURE_MODE
};

struct ov5640_priv {
    struct v4l2_subdev                  subdev;
    struct media_pad                    pad;
    struct v4l2_ctrl_handler            hdl;
    const struct ov5640_color_format    *cfmt;
    const struct ov5640_win_size        *win;
    int                                 model;
    bool                                initialized;

    /**
     * ctrls
    */
    /* standard */
    struct v4l2_ctrl * pbrightness;
    struct v4l2_ctrl *pcontrast;
    struct v4l2_ctrl * pauto_white_balance;
    struct v4l2_ctrl * pexposure;
    struct v4l2_ctrl * pgain;
    struct v4l2_ctrl * phflip;
    struct v4l2_ctrl * pwhite_balance_temperature;
    /* menu */
    struct v4l2_ctrl * pcolorfx;
    struct v4l2_ctrl * pexposure_auto;
    /* custom */
    struct v4l2_ctrl * pscene_exposure;
    struct v4l2_ctrl * pprev_capt;

    struct v4l2_rect rect; /* Sensor window */
    struct v4l2_fract timeperframe;
    enum prev_capt prev_capt_mode;
    exposure_param_t preview_exposure_param;
    exposure_param_t capture_exposure_param;



    int  nmodel;
    int nbrightness;
    int ncontrast;
    int nsaturation;
    int nhue;
    int nexposure;
    int nsharpness;
    int ncolorfx;
    int nflip_flag;

};

#endif

enum {
    AUTO_FOCUS_FAILED,
    AUTO_FOCUS_DONE,
    AUTO_FOCUS_CANCELLED,
};

/*
 * sensor ID
 */
#define OV5640  0x5640
#define VERSION(id, vers) ((id << 8) | (vers & 0XFF))


int down_af_firmware_flag = 0;


/* init 800X600 SVGA */
static struct regval sensor_init_data[] =
{
        {0x3103, 0x11},
        {0x3008, 0x82},
        {0x3008, 0x42},
        {0x3103, 0x03},
        {0x3017, 0xff},
        {0x3018, 0xff},
        {0x3034, 0x1a},
        {0x3035, 0x21},
        {0x3036, 0x46},
        {0x3037, 0x13},
        {0x3108, 0x01},
        {0x3630, 0x36},
        {0x3631, 0x0e},
        {0x3632, 0xe2},
        {0x3633, 0x12},
        {0x3621, 0xe0},
        {0x3704, 0xa0},
        {0x3703, 0x5a},
        {0x3715, 0x78},
        {0x3717, 0x01},
        {0x370b, 0x60},
        {0x3705, 0x1a},
        {0x3905, 0x02},
        {0x3906, 0x10},
        {0x3901, 0x0a},
        {0x3731, 0x12},
        {0x3600, 0x08},
        {0x3601, 0x33},
        {0x302d, 0x60},
        {0x3620, 0x52},
        {0x371b, 0x20},
        {0x471c, 0x50},
        {0x3a13, 0x43},
        {0x3a18, 0x00},
        {0x3a19, 0xf8},
        {0x3635, 0x13},
        {0x3636, 0x03},
        {0x3634, 0x40},
        {0x3622, 0x01},
        {0x3c01, 0x34},
        {0x3c04, 0x28},
        {0x3c05, 0x98},
        {0x3c06, 0x00},
        {0x3c07, 0x08},
        {0x3c08, 0x00},
        {0x3c09, 0x1c},
        {0x3c0a, 0x9c},
        {0x3c0b, 0x40},
        {0x3820, 0x41},
        {0x3821, 0x07},
        {0x3814, 0x31},
        {0x3815, 0x31},
        {0x3800, 0x00},
        {0x3801, 0x00},
        {0x3802, 0x00},
        {0x3803, 0x04},
        {0x3804, 0x0a},
        {0x3805, 0x3f},
        {0x3806, 0x07},
        {0x3807, 0x9b},


        {0x3808, 0x03},
        {0x3809, 0x20},
        {0x380a, 0x02},
        {0x380b, 0x58},



        {0x380c, 0x07},
        {0x380d, 0x68},
        {0x380e, 0x03},
        {0x380f, 0xd8},
        {0x3810, 0x00},
        {0x3811, 0x10},
        {0x3812, 0x00},
        {0x3813, 0x06},
        {0x3618, 0x00},
        {0x3612, 0x29},
        {0x3708, 0x64},
        {0x3709, 0x52},
        {0x370c, 0x03},
        {0x3a02, 0x03},
        {0x3a03, 0xd8},
        {0x3a08, 0x01},
        {0x3a09, 0x27},
        {0x3a0a, 0x00},
        {0x3a0b, 0xf6},
        {0x3a0e, 0x03},
        {0x3a0d, 0x04},
        {0x3a14, 0x03},
        {0x3a15, 0xd8},
        {0x4001, 0x02},
        {0x4004, 0x02},
        {0x3000, 0x00},
        {0x3002, 0x1c},
        {0x3004, 0xff},
        {0x3006, 0xc3},
        {0x300e, 0x58},
        {0x302e, 0x00},
        {0x4740, 0x20},
        {0x4300, 0x30},	//0x30 YUYV  0x31 YVYU 0x33 VYUY 0x32 UYVY
        {0x501f, 0x00},
        {0x4713, 0x03},
        {0x4407, 0x04},
        {0x440e, 0x00},
        {0x460b, 0x35},
        {0x460c, 0x20},
        {0x4837, 0x22},
        {0x3824, 0x02},
        {0x5000, 0xa7},
        {0x5001, 0xa3},
        {0x5180, 0xff},
        {0x5181, 0xf2},
        {0x5182, 0x00},
        {0x5183, 0x14},
        {0x5184, 0x25},
        {0x5185, 0x24},
        {0x5186, 0x09},
        {0x5187, 0x09},
        {0x5188, 0x09},
        {0x5189, 0x75},
        {0x518a, 0x54},
        {0x518b, 0xe0},
        {0x518c, 0xb2},
        {0x518d, 0x42},
        {0x518e, 0x3d},
        {0x518f, 0x56},
        {0x5190, 0x46},
        {0x5191, 0xf8},
        {0x5192, 0x04},
        {0x5193, 0x70},
        {0x5194, 0xf0},
        {0x5195, 0xf0},
        {0x5196, 0x03},
        {0x5197, 0x01},
        {0x5198, 0x04},
        {0x5199, 0x12},
        {0x519a, 0x04},
        {0x519b, 0x00},
        {0x519c, 0x06},
        {0x519d, 0x82},
        {0x519e, 0x38},
        {0x5381, 0x1e},
        {0x5382, 0x5b},
        {0x5383, 0x08},
        {0x5384, 0x0a},
        {0x5385, 0x7e},
        {0x5386, 0x88},
        {0x5387, 0x7c},
        {0x5388, 0x6c},
        {0x5389, 0x10},
        {0x538a, 0x01},
        {0x538b, 0x98},
        {0x5300, 0x08},
        {0x5301, 0x30},
        {0x5302, 0x10},
        {0x5303, 0x00},
        {0x5304, 0x08},
        {0x5305, 0x30},
        {0x5306, 0x08},
        {0x5307, 0x16},
        {0x5309, 0x08},
        {0x530a, 0x30},
        {0x530b, 0x04},
        {0x530c, 0x06},
        {0x5480, 0x01},
        {0x5481, 0x08},
        {0x5482, 0x14},
        {0x5483, 0x28},
        {0x5484, 0x51},
        {0x5485, 0x65},
        {0x5486, 0x71},
        {0x5487, 0x7d},
        {0x5488, 0x87},
        {0x5489, 0x91},
        {0x548a, 0x9a},
        {0x548b, 0xaa},
        {0x548c, 0xb8},
        {0x548d, 0xcd},
        {0x548e, 0xdd},
        {0x548f, 0xea},
        {0x5490, 0x1d},
        {0x5580, 0x02},
        {0x5583, 0x40},
        {0x5584, 0x10},
        {0x5589, 0x10},
        {0x558a, 0x00},
        {0x558b, 0xf8},
        {0x5800, 0x23},
        {0x5801, 0x14},
        {0x5802, 0x0f},
        {0x5803, 0x0f},
        {0x5804, 0x12},
        {0x5805, 0x26},
        {0x5806, 0x0c},
        {0x5807, 0x08},
        {0x5808, 0x05},
        {0x5809, 0x05},
        {0x580a, 0x08},
        {0x580b, 0x0d},
        {0x580c, 0x08},
        {0x580d, 0x03},
        {0x580e, 0x00},
        {0x580f, 0x00},
        {0x5810, 0x03},
        {0x5811, 0x09},
        {0x5812, 0x07},
        {0x5813, 0x03},
        {0x5814, 0x00},
        {0x5815, 0x01},
        {0x5816, 0x03},
        {0x5817, 0x08},
        {0x5818, 0x0d},
        {0x5819, 0x08},
        {0x581a, 0x05},
        {0x581b, 0x06},
        {0x581c, 0x08},
        {0x581d, 0x0e},
        {0x581e, 0x29},
        {0x581f, 0x17},
        {0x5820, 0x11},
        {0x5821, 0x11},
        {0x5822, 0x15},
        {0x5823, 0x28},
        {0x5824, 0x46},
        {0x5825, 0x26},
        {0x5826, 0x08},
        {0x5827, 0x26},
        {0x5828, 0x64},
        {0x5829, 0x26},
        {0x582a, 0x24},
        {0x582b, 0x22},
        {0x582c, 0x24},
        {0x582d, 0x24},
        {0x582e, 0x06},
        {0x582f, 0x22},
        {0x5830, 0x40},
        {0x5831, 0x42},
        {0x5832, 0x24},
        {0x5833, 0x26},
        {0x5834, 0x24},
        {0x5835, 0x22},
        {0x5836, 0x22},
        {0x5837, 0x26},
        {0x5838, 0x44},
        {0x5839, 0x24},
        {0x583a, 0x26},
        {0x583b, 0x28},
        {0x583c, 0x42},
        {0x583d, 0xce},
        {0x5025, 0x00},
        {0x3a0f, 0x30},
        {0x3a10, 0x28},
        {0x3a1b, 0x30},
        {0x3a1e, 0x26},
        {0x3a11, 0x60},
        {0x3a1f, 0x14},
        {0x3008, 0x02},
};


static const struct regval ov5640_init_regs[] = {
    /* for the setting , 24M Mlck input and 24M Plck output */
{0x3103, 0x11},
{0x3008, 0x82}, /* soft reset */
{0x3008, 0x42},
{0x3103, 0x03}, /* input clock, from PLL */
{0x3017, 0xff}, /* d[9:0] pins I/O ctrl */
{0x3018, 0xff},
/* system control */
{0x3034, 0x1a}, /* MIPI 10-bit mode */
{0x3035, 0x11}, /* clock, PLL sets */
{0x3036, 0x46},
{0x3037, 0x13},
{0x3108, 0x01}, /* SCCB CLK root divider */
{0x3630, 0x36},
{0x3631, 0x0e},
{0x3632, 0xe2},
{0x3633, 0x12},
{0x3621, 0xe0},
{0x3704, 0xa0},
{0x3703, 0x5a},
{0x3715, 0x78},
{0x3717, 0x01},
{0x370b, 0x60},
{0x3705, 0x1a},
{0x3905, 0x02},
{0x3906, 0x10},
{0x3901, 0x0a},
{0x3731, 0x12},
{0x3600, 0x08},
{0x3601, 0x33},
{0x302d, 0x60},
{0x3620, 0x52},
{0x371b, 0x20},
{0x471c, 0x50},
{0x3a13, 0x43},
{0x3a18, 0x00},
{0x3a19, 0xf8},
{0x3635, 0x13},
{0x3636, 0x03},
{0x3634, 0x40},
{0x3622, 0x01},

{0x3c01, 0x34},  /* 50/60HZ detector */
{0x3c04, 0x28},
{0x3c05, 0x98},
{0x3c06, 0x00},
{0x3c07, 0x08},
{0x3c08, 0x00},
{0x3c09, 0x1c},
{0x3c0a, 0x9c},
{0x3c0b, 0x40},

{0x3820, 0x41}, /* mirror and flip */
{0x3821, 0x07},

{0x3814, 0x31}, /* image windowing */
{0x3815, 0x31},
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x04},
{0x3804, 0x0a},
{0x3805, 0x3f},
{0x3806, 0x07},
{0x3807, 0x9b},
{0x3808, 0x02}, /* 0x280==640 */
{0x3809, 0x80},
{0x380a, 0x01}, /* 0x1e0==480 */
{0x380b, 0xe0},
{0x380c, 0x07},
{0x380d, 0x68},
{0x380e, 0x03},
{0x380f, 0xd8},
{0x3810, 0x00},
{0x3811, 0x10},
{0x3812, 0x00},
{0x3813, 0x06},

{0x3618, 0x00},
{0x3612, 0x29},
{0x3708, 0x64},
{0x3709, 0x52},
{0x370c, 0x03},

{0x3a02, 0x03}, /* AEC/AGC control */
{0x3a03, 0xd8},
{0x3a08, 0x01},
{0x3a09, 0x27},
{0x3a0a, 0x00},
{0x3a0b, 0xf6},
{0x3a0e, 0x03},
{0x3a0d, 0x04},
{0x3a14, 0x03},
{0x3a15, 0xd8},

{0x4001, 0x02}, /* BLC start line */
{0x4004, 0x02}, /* BLC line number */
{0x3000, 0x00}, /* block enable */
{0x3002, 0x1c},
{0x3004, 0xff}, /* clock enable */
{0x3006, 0xc3},
{0x300e, 0x58},
{0x302e, 0x00},

//{0x4300, 0x32}, /* format ctrl: YUV422 UYVY */
{0x4300, 0x30}, /* format ctrl: YUV422 YUYV */

{0x501f, 0x00}, /* format MUX ctrl: ISP YUV422 */
{0x4713, 0x03}, /* jpeg mode select: mode 3 */
{0x4407, 0x04}, /* jpeg ctrl */
{0x440e, 0x00},
{0x460b, 0x35}, /* VFIFO ctrl */
{0x460c, 0x22},
{0x3824, 0x02},
{0x5000, 0xa7}, /* ISP top ctrl */
{0x5001, 0xa3},

{0x5180, 0xff}, /* AWB ctrl */
{0x5181, 0xf2},
{0x5182, 0x00},
{0x5183, 0x14},
{0x5184, 0x25},
{0x5185, 0x24},
{0x5186, 0x09},
{0x5187, 0x09},
{0x5188, 0x09},
{0x5189, 0x75},
{0x518a, 0x54},
{0x518b, 0xe0},
{0x518c, 0xb2},
{0x518d, 0x42},
{0x518e, 0x3d},
{0x518f, 0x56},
{0x5190, 0x46},
{0x5191, 0xf8},
{0x5192, 0x04},
{0x5193, 0x70},
{0x5194, 0xf0},
{0x5195, 0xf0},
{0x5196, 0x03},
{0x5197, 0x01},
{0x5198, 0x04},
{0x5199, 0x12},
{0x519a, 0x04},
{0x519b, 0x00},
{0x519c, 0x06},
{0x519d, 0x82},
{0x519e, 0x38},

{0x5381, 0x1e}, /* Color matrix */
{0x5382, 0x5b},
{0x5383, 0x08},
{0x5384, 0x0a},
{0x5385, 0x7e},
{0x5386, 0x88},
{0x5387, 0x7c},
{0x5388, 0x6c},
{0x5389, 0x10},
{0x538a, 0x01},
{0x538b, 0x98},

{0x5300, 0x08}, /* Color interpolation */
{0x5301, 0x30},
{0x5302, 0x10},
{0x5303, 0x00},
{0x5304, 0x08},
{0x5305, 0x30},
{0x5306, 0x08},
{0x5307, 0x16},
{0x5309, 0x08},
{0x530a, 0x30},
{0x530b, 0x04},
{0x530c, 0x06},

{0x5480, 0x01}, /* gamma ctrl */
{0x5481, 0x08},
{0x5482, 0x14},
{0x5483, 0x28},
{0x5484, 0x51},
{0x5485, 0x65},
{0x5486, 0x71},
{0x5487, 0x7d},
{0x5488, 0x87},
{0x5489, 0x91},
{0x548a, 0x9a},
{0x548b, 0xaa},
{0x548c, 0xb8},
{0x548d, 0xcd},
{0x548e, 0xdd},
{0x548f, 0xea},
{0x5490, 0x1d},

{0x5580, 0x02}, /* special digital effects(SDE) */
{0x5583, 0x40},
{0x5584, 0x10},
{0x5589, 0x10},
{0x558a, 0x00},
{0x558b, 0xf8},

{0x5800, 0x23}, /* LENC ctrl */
{0x5801, 0x14},
{0x5802, 0x0f},
{0x5803, 0x0f},
{0x5804, 0x12},
{0x5805, 0x26},
{0x5806, 0x0c},
{0x5807, 0x08},
{0x5808, 0x05},
{0x5809, 0x05},
{0x580a, 0x08},
{0x580b, 0x0d},
{0x580c, 0x08},
{0x580d, 0x03},
{0x580e, 0x00},
{0x580f, 0x00},
{0x5810, 0x03},
{0x5811, 0x09},
{0x5812, 0x07},
{0x5813, 0x03},
{0x5814, 0x00},
{0x5815, 0x01},
{0x5816, 0x03},
{0x5817, 0x08},
{0x5818, 0x0d},
{0x5819, 0x08},
{0x581a, 0x05},
{0x581b, 0x06},
{0x581c, 0x08},
{0x581d, 0x0e},
{0x581e, 0x29},
{0x581f, 0x17},
{0x5820, 0x11},
{0x5821, 0x11},
{0x5822, 0x15},
{0x5823, 0x28},
{0x5824, 0x46},
{0x5825, 0x26},
{0x5826, 0x08},
{0x5827, 0x26},
{0x5828, 0x64},
{0x5829, 0x26},
{0x582a, 0x24},
{0x582b, 0x22},
{0x582c, 0x24},
{0x582d, 0x24},
{0x582e, 0x06},
{0x582f, 0x22},
{0x5830, 0x40},
{0x5831, 0x42},
{0x5832, 0x24},
{0x5833, 0x26},
{0x5834, 0x24},
{0x5835, 0x22},
{0x5836, 0x22},
{0x5837, 0x26},
{0x5838, 0x44},
{0x5839, 0x24},
{0x583a, 0x26},
{0x583b, 0x28},
{0x583c, 0x42},
{0x583d, 0xce},
{0x5025, 0x00},

{0x3a0f, 0x30}, /* AEC functions */
{0x3a10, 0x28},
{0x3a1b, 0x30},
{0x3a1e, 0x26},
{0x3a11, 0x60},
{0x3a1f, 0x14},

{0x3008, 0x02}, /* soft reset/pwd default value */
{0x3035, 0x21}, /* SC PLL ctrl */

{0x3c01, 0xb4}, /* Band, 0x50Hz */
{0x3c00, 0x04},

{0x3a19, 0x7c}, /* gain ceiling */

{0x5800, 0x2c}, /* OV5640 LENC setting */
{0x5801, 0x17},
{0x5802, 0x11},
{0x5803, 0x11},
{0x5804, 0x15},
{0x5805, 0x29},
{0x5806, 0x08},
{0x5807, 0x06},
{0x5808, 0x04},
{0x5809, 0x04},
{0x580a, 0x05},
{0x580b, 0x07},
{0x580c, 0x06},
{0x580d, 0x03},
{0x580e, 0x01},
{0x580f, 0x01},
{0x5810, 0x03},
{0x5811, 0x06},
{0x5812, 0x06},
{0x5813, 0x02},
{0x5814, 0x01},
{0x5815, 0x01},
{0x5816, 0x04},
{0x5817, 0x07},
{0x5818, 0x06},
{0x5819, 0x07},
{0x581a, 0x06},
{0x581b, 0x06},
{0x581c, 0x06},
{0x581d, 0x0e},
{0x581e, 0x31},
{0x581f, 0x12},
{0x5820, 0x11},
{0x5821, 0x11},
{0x5822, 0x11},
{0x5823, 0x2f},
{0x5824, 0x12},
{0x5825, 0x25},
{0x5826, 0x39},
{0x5827, 0x29},
{0x5828, 0x27},
{0x5829, 0x39},
{0x582a, 0x26},
{0x582b, 0x33},
{0x582c, 0x24},
{0x582d, 0x39},
{0x582e, 0x28},
{0x582f, 0x21},
{0x5830, 0x40},
{0x5831, 0x21},
{0x5832, 0x17},
{0x5833, 0x17},
{0x5834, 0x15},
{0x5835, 0x11},
{0x5836, 0x24},
{0x5837, 0x27},
{0x5838, 0x26},
{0x5839, 0x26},
{0x583a, 0x26},
{0x583b, 0x28},
{0x583c, 0x14},
{0x583d, 0xee},
{0x4005, 0x1a}, /* BLC always update */

{0x5381, 0x26}, /* color matrix ctrl */
{0x5382, 0x50},
{0x5383, 0x0c},
{0x5384, 0x09},
{0x5385, 0x74},
{0x5386, 0x7d},
{0x5387, 0x7e},
{0x5388, 0x75},
{0x5389, 0x09},
{0x538b, 0x98},
{0x538a, 0x01},

{0x5580, 0x02}, /* (SDE)UVAdjust Auto Mode */
{0x5588, 0x01},
{0x5583, 0x40},
{0x5584, 0x10},
{0x5589, 0x0f},
{0x558a, 0x00},
{0x558b, 0x3f},

{0x5308, 0x25}, /* De-Noise, 0xAuto */
{0x5304, 0x08},
{0x5305, 0x30},
{0x5306, 0x10},
{0x5307, 0x20},

{0x5180, 0xff}, /* awb ctrl */
{0x5181, 0xf2},
{0x5182, 0x11},
{0x5183, 0x14},
{0x5184, 0x25},
{0x5185, 0x24},
{0x5186, 0x10},
{0x5187, 0x12},
{0x5188, 0x10},
{0x5189, 0x80},
{0x518a, 0x54},
{0x518b, 0xb8},
{0x518c, 0xb2},
{0x518d, 0x42},
{0x518e, 0x3a},
{0x518f, 0x56},
{0x5190, 0x46},
{0x5191, 0xf0},
{0x5192, 0xf},
{0x5193, 0x70},
{0x5194, 0xf0},
{0x5195, 0xf0},
{0x5196, 0x3},
{0x5197, 0x1},
{0x5198, 0x6},
{0x5199, 0x62},
{0x519a, 0x4},
{0x519b, 0x0},
{0x519c, 0x4},
{0x519d, 0xe7},
{0x519e, 0x38},

};




static const struct regval ov5640_qsxga_regs[] = {
{0x3820, 0x40},  /* diff. init */
{0x3821, 0x06},
{0x3814, 0x11}, /* image windowing */
{0x3815, 0x11},
{0x3803, 0x00},
{0x3807, 0x9f},
{0x3808, 0x0a}, /* 0x0a20==2592 */
{0x3809, 0x20},
{0x380a, 0x07}, /* 0x798==1944 */
{0x380b, 0x98},
{0x380c, 0x0b},
{0x380d, 0x1c},
{0x380e, 0x07},
{0x380f, 0xb0},
{0x3813, 0x04},

{0x3618, 0x04},
{0x3612, 0x4b},
{0x3708, 0x21},
{0x3709, 0x12},
{0x370c, 0x00},
{0x3a02, 0x07}, /* night mode */
{0x3a03, 0xb0},
{0x3a0e, 0x06},
{0x3a0d, 0x08},
{0x3a14, 0x07},
{0x3a15, 0xb0},

{0x4004, 0x06}, /* BLC line number */
{0x5000, 0x07}, /* black/white pixel cancell, color interp. enable */
{0x5181, 0x52}, /* AWB */
{0x5182, 0x00},
{0x5197, 0x01},
{0x519e, 0x38},

{0x3035, 0x21}, /* SC PLL */
{0x5000, 0x27},
{0x5001, 0x83}, /* special effect, color matrix, AWB enable */
{0x3035, 0x71},
{0x4713, 0x02}, /* jpeg mode 2 */
{0x3036, 0x69},
{0x4407, 0x0c}, /* jpeg ctrl */
{0x460b, 0x37},
{0x460c, 0x20},
{0x3824, 0x01},
{0x4005, 0x1A},


ENDMARKER,
};

/*
static const struct regval ov5640_qsxga_to_qvga_regs[] = {

};
*/

static const struct regval ov5640_qsxga_to_vga_regs[] = {
{0x3800, 0x00}, /* image windowing */
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0xA },
{0x3805, 0x3f},
{0x3806, 0x7 },
{0x3807, 0x9f},
{0x3808, 0x2 }, /* 0x280== 640*/
{0x3809, 0x80},
{0x380a, 0x1 }, /* 0x1e0== 480*/
{0x380b, 0xe0},
{0x380c, 0xc },
{0x380d, 0x80},
{0x380e, 0x7 },
{0x380f, 0xd0},

{0x5001, 0xa3}, /* SDE, scaling, color matrix, AWB enable */
{0x5680, 0x0 }, /* AVG ctrl */
{0x5681, 0x0 },
{0x5682, 0xA },
{0x5683, 0x20},
{0x5684, 0x0 },
{0x5685, 0x0 },
{0x5686, 0x7 },
{0x5687, 0x98},

ENDMARKER,

};


static const struct regval ov5640_qsxga_to_xga_regs[] = {
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0xA },
{0x3805, 0x3f},
{0x3806, 0x7 },
{0x3807, 0x9f},
{0x3808, 0x4 }, /* 0x400==1024 */
{0x3809, 0x0 },
{0x380a, 0x3 }, /* 0x300== 768*/
{0x380b, 0x0 },
{0x380c, 0xc },
{0x380d, 0x80},
{0x380e, 0x7 },
{0x380f, 0xd0},
{0x5001, 0xa3},
{0x5680, 0x0 },
{0x5681, 0x0 },
{0x5682, 0xA },
{0x5683, 0x20},
{0x5684, 0x0 },
{0x5685, 0x0 },
{0x5686, 0x7 },
{0x5687, 0x98},

ENDMARKER,
};


static const struct regval ov5640_qsxga_to_sxga_regs[] = {
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0xA },
{0x3805, 0x3f},
{0x3806, 0x7 },
{0x3807, 0x9f},
{0x3808, 0x5 }, /* 0x500==1280 */
{0x3809, 0x0 },
{0x380a, 0x3 }, /* 0x3c0==960 */
{0x380b, 0xc0},
{0x380c, 0xc },
{0x380d, 0x80},
{0x380e, 0x7 },
{0x380f, 0xd0},
{0x5001, 0xa3},
{0x5680, 0x0 },
{0x5681, 0x0 },
{0x5682, 0xA },
{0x5683, 0x20},
{0x5684, 0x0 },
{0x5685, 0x0 },
{0x5686, 0x7 },
{0x5687, 0x98},

ENDMARKER,

};

static const struct regval ov5640_qsxga_to_uxga_regs[] = {
#if 0
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0xA },
{0x3805, 0x3f},
{0x3806, 0x7 },
{0x3807, 0x9f},
{0x3808, 0x6 }, /* 0x640== 1600*/
{0x3809, 0x40},
{0x380a, 0x4 }, /* 0x4b0==1200 */
{0x380b, 0xb0},
{0x380c, 0xc },
{0x380d, 0x80},
{0x380e, 0x7 },
{0x380f, 0xd0},
{0x5001, 0xa3},
{0x5680, 0x0 },
{0x5681, 0x0 },
{0x5682, 0xA },
{0x5683, 0x20},
{0x5684, 0x0 },
{0x5685, 0x0 },
{0x5686, 0x7 },
{0x5687, 0x98},
ENDMARKER,
#else
{0x3503, 0x07},
{0x3a00, 0x38},
{0x4050, 0x6e},
{0x4051, 0x8f},
{0x5302, 0x1c},
{0x5303, 0x08},
{0x5306, 0x0c},
{0x5307, 0x1c},
{0x3820, 0x40},
{0x3821, 0x06},
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0x0a},
{0x3805, 0x3f},
{0x3806, 0x07},
{0x3807, 0x9f},
{0x3808, 0x0a},
{0x3809, 0x20},
{0x380a, 0x07},
{0x380b, 0x98},
{0x3810, 0x00},
{0x3811, 0x10},
{0x3812, 0x00},
{0x3813, 0x04},
{0x3814, 0x11},
{0x3815, 0x11},

{0x3034, 0x1a},
{0x3035, 0x11},
{0x3036, 0x46},
{0x3037, 0x13},
{0x3038, 0x00},
{0x3039, 0x00},

{0x380c, 0x0b},
{0x380d, 0x1c},
{0x380e, 0x07},
{0x380f, 0xb0},

{0x3a08, 0x00},
{0x3a09, 0xc5},
{0x3a0e, 0x0a},
{0x3a0a, 0x00},
{0x3a0b, 0xa4},
{0x3a0d, 0x0c},

{0x3618, 0x04},
{0x3612, 0x2b},
{0x3709, 0x12},
{0x370c, 0x00},

{0x4004, 0x06},
{0x3002, 0x00},
{0x3006, 0xff},
{0x4713, 0x02},
{0x4407, 0x04},
{0x460b, 0x37},
{0x460c, 0x22},
{0x4837, 0x16},
{0x3824, 0x01},
{0x5001, 0x83},

{0x4202,0x00},
ENDMARKER,
#endif
};


static const struct regval ov5640_qsxga_to_qxga_regs[] = {
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0xA },
{0x3805, 0x3f},
{0x3806, 0x7 },
{0x3807, 0x9f},
{0x3808, 0x8 }, /* 0x800==2048 */
{0x3809, 0x0 },
{0x380a, 0x6 }, /* 0x600==1536 */
{0x380b, 0x0 },
{0x380c, 0xc },
{0x380d, 0x80},
{0x380e, 0x7 },
{0x380f, 0xd0},
{0x5001, 0xa3},
{0x5680, 0x0 },
{0x5681, 0x0 },
{0x5682, 0xA },
{0x5683, 0x20},
{0x5684, 0x0 },
{0x5685, 0x0 },
{0x5686, 0x7 },
{0x5687, 0x98},
ENDMARKER,
};

static char ov5640_sensor_af_fw_regs[] = {
    0x02, 0x0f, 0xd6, 0x02, 0x0a, 0x39, 0xc2, 0x01, 0x22, 0x22, 0x00, 0x02, 0x0f, 0xb2, 0xe5, 0x1f, //0x8000,
    0x70, 0x72, 0xf5, 0x1e, 0xd2, 0x35, 0xff, 0xef, 0x25, 0xe0, 0x24, 0x4e, 0xf8, 0xe4, 0xf6, 0x08, //0x8010,
    0xf6, 0x0f, 0xbf, 0x34, 0xf2, 0x90, 0x0e, 0x93, 0xe4, 0x93, 0xff, 0xe5, 0x4b, 0xc3, 0x9f, 0x50, //0x8020,
    0x04, 0x7f, 0x05, 0x80, 0x02, 0x7f, 0xfb, 0x78, 0xbd, 0xa6, 0x07, 0x12, 0x0f, 0x04, 0x40, 0x04, //0x8030,
    0x7f, 0x03, 0x80, 0x02, 0x7f, 0x30, 0x78, 0xbc, 0xa6, 0x07, 0xe6, 0x18, 0xf6, 0x08, 0xe6, 0x78, //0x8040,
    0xb9, 0xf6, 0x78, 0xbc, 0xe6, 0x78, 0xba, 0xf6, 0x78, 0xbf, 0x76, 0x33, 0xe4, 0x08, 0xf6, 0x78, //0x8050,
    0xb8, 0x76, 0x01, 0x75, 0x4a, 0x02, 0x78, 0xb6, 0xf6, 0x08, 0xf6, 0x74, 0xff, 0x78, 0xc1, 0xf6, //0x8060,
    0x08, 0xf6, 0x75, 0x1f, 0x01, 0x78, 0xbc, 0xe6, 0x75, 0xf0, 0x05, 0xa4, 0xf5, 0x4b, 0x12, 0x0a, //0x8070,
    0xff, 0xc2, 0x37, 0x22, 0x78, 0xb8, 0xe6, 0xd3, 0x94, 0x00, 0x40, 0x02, 0x16, 0x22, 0xe5, 0x1f, //0x8080,
    0xb4, 0x05, 0x23, 0xe4, 0xf5, 0x1f, 0xc2, 0x01, 0x78, 0xb6, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x78, //0x8090,
    0x4e, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0xa2, 0x37, 0xe4, 0x33, 0xf5, 0x3c, 0x90, 0x30, 0x28, 0xf0, //0x80a0,
    0x75, 0x1e, 0x10, 0xd2, 0x35, 0x22, 0xe5, 0x4b, 0x75, 0xf0, 0x05, 0x84, 0x78, 0xbc, 0xf6, 0x90, //0x80b0,
    0x0e, 0x8c, 0xe4, 0x93, 0xff, 0x25, 0xe0, 0x24, 0x0a, 0xf8, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x78, //0x80c0,
    0xbc, 0xe6, 0x25, 0xe0, 0x24, 0x4e, 0xf8, 0xa6, 0x04, 0x08, 0xa6, 0x05, 0xef, 0x12, 0x0f, 0x0b, //0x80d0,
    0xd3, 0x78, 0xb7, 0x96, 0xee, 0x18, 0x96, 0x40, 0x0d, 0x78, 0xbc, 0xe6, 0x78, 0xb9, 0xf6, 0x78, //0x80e0,
    0xb6, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x90, 0x0e, 0x8c, 0xe4, 0x93, 0x12, 0x0f, 0x0b, 0xc3, 0x78, //0x80f0,
    0xc2, 0x96, 0xee, 0x18, 0x96, 0x50, 0x0d, 0x78, 0xbc, 0xe6, 0x78, 0xba, 0xf6, 0x78, 0xc1, 0xa6, //0x8100,
    0x06, 0x08, 0xa6, 0x07, 0x78, 0xb6, 0xe6, 0xfe, 0x08, 0xe6, 0xc3, 0x78, 0xc2, 0x96, 0xff, 0xee, //0x8110,
    0x18, 0x96, 0x78, 0xc3, 0xf6, 0x08, 0xa6, 0x07, 0x90, 0x0e, 0x95, 0xe4, 0x18, 0x12, 0x0e, 0xe9, //0x8120,
    0x40, 0x02, 0xd2, 0x37, 0x78, 0xbc, 0xe6, 0x08, 0x26, 0x08, 0xf6, 0xe5, 0x1f, 0x64, 0x01, 0x70, //0x8130,
    0x4a, 0xe6, 0xc3, 0x78, 0xc0, 0x12, 0x0e, 0xdf, 0x40, 0x05, 0x12, 0x0e, 0xda, 0x40, 0x39, 0x12, //0x8140,
    0x0f, 0x02, 0x40, 0x04, 0x7f, 0xfe, 0x80, 0x02, 0x7f, 0x02, 0x78, 0xbd, 0xa6, 0x07, 0x78, 0xb9, //0x8150,
    0xe6, 0x24, 0x03, 0x78, 0xbf, 0xf6, 0x78, 0xb9, 0xe6, 0x24, 0xfd, 0x78, 0xc0, 0xf6, 0x12, 0x0f, //0x8160,
    0x02, 0x40, 0x06, 0x78, 0xc0, 0xe6, 0xff, 0x80, 0x04, 0x78, 0xbf, 0xe6, 0xff, 0x78, 0xbe, 0xa6, //0x8170,
    0x07, 0x75, 0x1f, 0x02, 0x78, 0xb8, 0x76, 0x01, 0x02, 0x02, 0x4a, 0xe5, 0x1f, 0x64, 0x02, 0x60, //0x8180,
    0x03, 0x02, 0x02, 0x2a, 0x78, 0xbe, 0xe6, 0xff, 0xc3, 0x78, 0xc0, 0x12, 0x0e, 0xe0, 0x40, 0x08, //0x8190,
    0x12, 0x0e, 0xda, 0x50, 0x03, 0x02, 0x02, 0x28, 0x12, 0x0f, 0x02, 0x40, 0x04, 0x7f, 0xff, 0x80, //0x81a0,
    0x02, 0x7f, 0x01, 0x78, 0xbd, 0xa6, 0x07, 0x78, 0xb9, 0xe6, 0x04, 0x78, 0xbf, 0xf6, 0x78, 0xb9, //0x81b0,
    0xe6, 0x14, 0x78, 0xc0, 0xf6, 0x18, 0x12, 0x0f, 0x04, 0x40, 0x04, 0xe6, 0xff, 0x80, 0x02, 0x7f, //0x81c0,
    0x00, 0x78, 0xbf, 0xa6, 0x07, 0xd3, 0x08, 0xe6, 0x64, 0x80, 0x94, 0x80, 0x40, 0x04, 0xe6, 0xff, //0x81d0,
    0x80, 0x02, 0x7f, 0x00, 0x78, 0xc0, 0xa6, 0x07, 0xc3, 0x18, 0xe6, 0x64, 0x80, 0x94, 0xb3, 0x50, //0x81e0,
    0x04, 0xe6, 0xff, 0x80, 0x02, 0x7f, 0x33, 0x78, 0xbf, 0xa6, 0x07, 0xc3, 0x08, 0xe6, 0x64, 0x80, //0x81f0,
    0x94, 0xb3, 0x50, 0x04, 0xe6, 0xff, 0x80, 0x02, 0x7f, 0x33, 0x78, 0xc0, 0xa6, 0x07, 0x12, 0x0f, //0x8200,
    0x02, 0x40, 0x06, 0x78, 0xc0, 0xe6, 0xff, 0x80, 0x04, 0x78, 0xbf, 0xe6, 0xff, 0x78, 0xbe, 0xa6, //0x8210,
    0x07, 0x75, 0x1f, 0x03, 0x78, 0xb8, 0x76, 0x01, 0x80, 0x20, 0xe5, 0x1f, 0x64, 0x03, 0x70, 0x26, //0x8220,
    0x78, 0xbe, 0xe6, 0xff, 0xc3, 0x78, 0xc0, 0x12, 0x0e, 0xe0, 0x40, 0x05, 0x12, 0x0e, 0xda, 0x40, //0x8230,
    0x09, 0x78, 0xb9, 0xe6, 0x78, 0xbe, 0xf6, 0x75, 0x1f, 0x04, 0x78, 0xbe, 0xe6, 0x75, 0xf0, 0x05, //0x8240,
    0xa4, 0xf5, 0x4b, 0x02, 0x0a, 0xff, 0xe5, 0x1f, 0xb4, 0x04, 0x10, 0x90, 0x0e, 0x94, 0xe4, 0x78, //0x8250,
    0xc3, 0x12, 0x0e, 0xe9, 0x40, 0x02, 0xd2, 0x37, 0x75, 0x1f, 0x05, 0x22, 0x30, 0x01, 0x03, 0x02, //0x8260,
    0x04, 0xc0, 0x30, 0x02, 0x03, 0x02, 0x04, 0xc0, 0x90, 0x51, 0xa5, 0xe0, 0x78, 0x93, 0xf6, 0xa3, //0x8270,
    0xe0, 0x08, 0xf6, 0xa3, 0xe0, 0x08, 0xf6, 0xe5, 0x1f, 0x70, 0x3c, 0x75, 0x1e, 0x20, 0xd2, 0x35, //0x8280,
    0x12, 0x0c, 0x7a, 0x78, 0x7e, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x78, 0x8b, 0xa6, 0x09, 0x18, 0x76, //0x8290,
    0x01, 0x12, 0x0c, 0x5b, 0x78, 0x4e, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x78, 0x8b, 0xe6, 0x78, 0x6e, //0x82a0,
    0xf6, 0x75, 0x1f, 0x01, 0x78, 0x93, 0xe6, 0x78, 0x90, 0xf6, 0x78, 0x94, 0xe6, 0x78, 0x91, 0xf6, //0x82b0,
    0x78, 0x95, 0xe6, 0x78, 0x92, 0xf6, 0x22, 0x79, 0x90, 0xe7, 0xd3, 0x78, 0x93, 0x96, 0x40, 0x05, //0x82c0,
    0xe7, 0x96, 0xff, 0x80, 0x08, 0xc3, 0x79, 0x93, 0xe7, 0x78, 0x90, 0x96, 0xff, 0x78, 0x88, 0x76, //0x82d0,
    0x00, 0x08, 0xa6, 0x07, 0x79, 0x91, 0xe7, 0xd3, 0x78, 0x94, 0x96, 0x40, 0x05, 0xe7, 0x96, 0xff, //0x82e0,
    0x80, 0x08, 0xc3, 0x79, 0x94, 0xe7, 0x78, 0x91, 0x96, 0xff, 0x12, 0x0c, 0x8e, 0x79, 0x92, 0xe7, //0x82f0,
    0xd3, 0x78, 0x95, 0x96, 0x40, 0x05, 0xe7, 0x96, 0xff, 0x80, 0x08, 0xc3, 0x79, 0x95, 0xe7, 0x78, //0x8300,
    0x92, 0x96, 0xff, 0x12, 0x0c, 0x8e, 0x12, 0x0c, 0x5b, 0x78, 0x8a, 0xe6, 0x25, 0xe0, 0x24, 0x4e, //0x8310,
    0xf8, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x78, 0x8a, 0xe6, 0x24, 0x6e, 0xf8, 0xa6, 0x09, 0x78, 0x8a, //0x8320,
    0xe6, 0x24, 0x01, 0xff, 0xe4, 0x33, 0xfe, 0xd3, 0xef, 0x94, 0x0f, 0xee, 0x64, 0x80, 0x94, 0x80, //0x8330,
    0x40, 0x04, 0x7f, 0x00, 0x80, 0x05, 0x78, 0x8a, 0xe6, 0x04, 0xff, 0x78, 0x8a, 0xa6, 0x07, 0xe5, //0x8340,
    0x1f, 0xb4, 0x01, 0x0a, 0xe6, 0x60, 0x03, 0x02, 0x04, 0xc0, 0x75, 0x1f, 0x02, 0x22, 0x12, 0x0c, //0x8350,
    0x7a, 0x78, 0x80, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0x12, 0x0c, 0x7a, 0x78, 0x82, 0xa6, 0x06, 0x08, //0x8360,
    0xa6, 0x07, 0x78, 0x6e, 0xe6, 0x78, 0x8c, 0xf6, 0x78, 0x6e, 0xe6, 0x78, 0x8d, 0xf6, 0x7f, 0x01, //0x8370,
    0xef, 0x25, 0xe0, 0x24, 0x4f, 0xf9, 0xc3, 0x78, 0x81, 0xe6, 0x97, 0x18, 0xe6, 0x19, 0x97, 0x50, //0x8380,
    0x0a, 0x12, 0x0c, 0x82, 0x78, 0x80, 0xa6, 0x04, 0x08, 0xa6, 0x05, 0x74, 0x6e, 0x2f, 0xf9, 0x78, //0x8390,
    0x8c, 0xe6, 0xc3, 0x97, 0x50, 0x08, 0x74, 0x6e, 0x2f, 0xf8, 0xe6, 0x78, 0x8c, 0xf6, 0xef, 0x25, //0x83a0,
    0xe0, 0x24, 0x4f, 0xf9, 0xd3, 0x78, 0x83, 0xe6, 0x97, 0x18, 0xe6, 0x19, 0x97, 0x40, 0x0a, 0x12, //0x83b0,
    0x0c, 0x82, 0x78, 0x82, 0xa6, 0x04, 0x08, 0xa6, 0x05, 0x74, 0x6e, 0x2f, 0xf9, 0x78, 0x8d, 0xe6, //0x83c0,
    0xd3, 0x97, 0x40, 0x08, 0x74, 0x6e, 0x2f, 0xf8, 0xe6, 0x78, 0x8d, 0xf6, 0x0f, 0xef, 0x64, 0x10, //0x83d0,
    0x70, 0x9e, 0xc3, 0x79, 0x81, 0xe7, 0x78, 0x83, 0x96, 0xff, 0x19, 0xe7, 0x18, 0x96, 0x78, 0x84, //0x83e0,
    0xf6, 0x08, 0xa6, 0x07, 0xc3, 0x79, 0x8c, 0xe7, 0x78, 0x8d, 0x96, 0x08, 0xf6, 0xd3, 0x79, 0x81, //0x83f0,
    0xe7, 0x78, 0x7f, 0x96, 0x19, 0xe7, 0x18, 0x96, 0x40, 0x05, 0x09, 0xe7, 0x08, 0x80, 0x06, 0xc3, //0x8400,
    0x79, 0x7f, 0xe7, 0x78, 0x81, 0x96, 0xff, 0x19, 0xe7, 0x18, 0x96, 0xfe, 0x78, 0x86, 0xa6, 0x06, //0x8410,
    0x08, 0xa6, 0x07, 0x79, 0x8c, 0xe7, 0xd3, 0x78, 0x8b, 0x96, 0x40, 0x05, 0xe7, 0x96, 0xff, 0x80, //0x8420,
    0x08, 0xc3, 0x79, 0x8b, 0xe7, 0x78, 0x8c, 0x96, 0xff, 0x78, 0x8f, 0xa6, 0x07, 0xe5, 0x1f, 0x64, //0x8430,
    0x02, 0x70, 0x69, 0x90, 0x0e, 0x91, 0x93, 0xff, 0x18, 0xe6, 0xc3, 0x9f, 0x50, 0x72, 0x12, 0x0c, //0x8440,
    0x4a, 0x12, 0x0c, 0x2f, 0x90, 0x0e, 0x8e, 0x12, 0x0c, 0x38, 0x78, 0x80, 0x12, 0x0c, 0x6b, 0x7b, //0x8450,
    0x04, 0x12, 0x0c, 0x1d, 0xc3, 0x12, 0x06, 0x45, 0x50, 0x56, 0x90, 0x0e, 0x92, 0xe4, 0x93, 0xff, //0x8460,
    0x78, 0x8f, 0xe6, 0x9f, 0x40, 0x02, 0x80, 0x11, 0x90, 0x0e, 0x90, 0xe4, 0x93, 0xff, 0xd3, 0x78, //0x8470,
    0x89, 0xe6, 0x9f, 0x18, 0xe6, 0x94, 0x00, 0x40, 0x03, 0x75, 0x1f, 0x05, 0x12, 0x0c, 0x4a, 0x12, //0x8480,
    0x0c, 0x2f, 0x90, 0x0e, 0x8f, 0x12, 0x0c, 0x38, 0x78, 0x7e, 0x12, 0x0c, 0x6b, 0x7b, 0x40, 0x12, //0x8490,
    0x0c, 0x1d, 0xd3, 0x12, 0x06, 0x45, 0x40, 0x18, 0x75, 0x1f, 0x05, 0x22, 0xe5, 0x1f, 0xb4, 0x05, //0x84a0,
    0x0f, 0xd2, 0x01, 0xc2, 0x02, 0xe4, 0xf5, 0x1f, 0xf5, 0x1e, 0xd2, 0x35, 0xd2, 0x33, 0xd2, 0x36, //0x84b0,
    0x22, 0xef, 0x8d, 0xf0, 0xa4, 0xa8, 0xf0, 0xcf, 0x8c, 0xf0, 0xa4, 0x28, 0xce, 0x8d, 0xf0, 0xa4, //0x84c0,
    0x2e, 0xfe, 0x22, 0xbc, 0x00, 0x0b, 0xbe, 0x00, 0x29, 0xef, 0x8d, 0xf0, 0x84, 0xff, 0xad, 0xf0, //0x84d0,
    0x22, 0xe4, 0xcc, 0xf8, 0x75, 0xf0, 0x08, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xec, 0x33, 0xfc, //0x84e0,
    0xee, 0x9d, 0xec, 0x98, 0x40, 0x05, 0xfc, 0xee, 0x9d, 0xfe, 0x0f, 0xd5, 0xf0, 0xe9, 0xe4, 0xce, //0x84f0,
    0xfd, 0x22, 0xed, 0xf8, 0xf5, 0xf0, 0xee, 0x84, 0x20, 0xd2, 0x1c, 0xfe, 0xad, 0xf0, 0x75, 0xf0, //0x8500,
    0x08, 0xef, 0x2f, 0xff, 0xed, 0x33, 0xfd, 0x40, 0x07, 0x98, 0x50, 0x06, 0xd5, 0xf0, 0xf2, 0x22, //0x8510,
    0xc3, 0x98, 0xfd, 0x0f, 0xd5, 0xf0, 0xea, 0x22, 0xe8, 0x8f, 0xf0, 0xa4, 0xcc, 0x8b, 0xf0, 0xa4, //0x8520,
    0x2c, 0xfc, 0xe9, 0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed, 0xa4, 0x2c, 0xfc, 0xea, 0x8e, //0x8530,
    0xf0, 0xa4, 0xcd, 0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38, 0x25, 0xf0, 0xfd, 0xe9, 0x8f, //0x8540,
    0xf0, 0xa4, 0x2c, 0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4, 0xfe, 0xa9, 0xf0, 0xeb, 0x8f, //0x8550,
    0xf0, 0xa4, 0xcf, 0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c, 0xfc, 0xea, 0xa4, 0x2d, 0xce, //0x8560,
    0x35, 0xf0, 0xfd, 0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x08, 0x75, 0x82, 0x00, 0xef, 0x2f, 0xff, //0x8570,
    0xee, 0x33, 0xfe, 0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82, 0x33, 0xc5, 0x82, 0x9b, 0xed, //0x8580,
    0x9a, 0xec, 0x99, 0xe5, 0x82, 0x98, 0x40, 0x0c, 0xf5, 0x82, 0xee, 0x9b, 0xfe, 0xed, 0x9a, 0xfd, //0x8590,
    0xec, 0x99, 0xfc, 0x0f, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4, 0xcd, 0xfa, 0xe4, 0xcc, 0xf9, //0x85a0,
    0xa8, 0x82, 0x22, 0xb8, 0x00, 0xc1, 0xb9, 0x00, 0x59, 0xba, 0x00, 0x2d, 0xec, 0x8b, 0xf0, 0x84, //0x85b0,
    0xcf, 0xce, 0xcd, 0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, //0x85c0,
    0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7, 0x03, 0x99, 0x40, 0x04, 0xeb, //0x85d0,
    0x99, 0xfb, 0x0f, 0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, //0x85e0,
    0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10, 0xd7, 0x05, 0x9b, 0xe9, 0x9a, //0x85f0,
    0x40, 0x07, 0xec, 0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0x0f, 0xd8, 0xe0, 0xe4, 0xc9, 0xfa, 0xe4, 0xcc, //0x8600,
    0xfb, 0x22, 0x75, 0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xcc, 0x33, //0x8610,
    0xcc, 0xc8, 0x33, 0xc8, 0x10, 0xd7, 0x07, 0x9b, 0xec, 0x9a, 0xe8, 0x99, 0x40, 0x0a, 0xed, 0x9b, //0x8620,
    0xfd, 0xec, 0x9a, 0xfc, 0xe8, 0x99, 0xf8, 0x0f, 0xd5, 0xf0, 0xda, 0xe4, 0xcd, 0xfb, 0xe4, 0xcc, //0x8630,
    0xfa, 0xe4, 0xc8, 0xf9, 0x22, 0xeb, 0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9, 0x9d, 0x42, //0x8640,
    0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22, 0xe8, 0x60, 0x0f, 0xec, 0xc3, 0x13, 0xfc, 0xed, 0x13, 0xfd, //0x8650,
    0xee, 0x13, 0xfe, 0xef, 0x13, 0xff, 0xd8, 0xf1, 0x22, 0xe8, 0x60, 0x0f, 0xef, 0xc3, 0x33, 0xff, //0x8660,
    0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe4, 0x93, 0xfc, 0x74, //0x8670,
    0x01, 0x93, 0xfd, 0x74, 0x02, 0x93, 0xfe, 0x74, 0x03, 0x93, 0xff, 0x22, 0xe6, 0xfb, 0x08, 0xe6, //0x8680,
    0xf9, 0x08, 0xe6, 0xfa, 0x08, 0xe6, 0xcb, 0xf8, 0x22, 0xec, 0xf6, 0x08, 0xed, 0xf6, 0x08, 0xee, //0x8690,
    0xf6, 0x08, 0xef, 0xf6, 0x22, 0xa4, 0x25, 0x82, 0xf5, 0x82, 0xe5, 0xf0, 0x35, 0x83, 0xf5, 0x83, //0x86a0,
    0x22, 0xd0, 0x83, 0xd0, 0x82, 0xf8, 0xe4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0d, 0xa3, //0x86b0,
    0xa3, 0x93, 0xf8, 0x74, 0x01, 0x93, 0xf5, 0x82, 0x88, 0x83, 0xe4, 0x73, 0x74, 0x02, 0x93, 0x68, //0x86c0,
    0x60, 0xef, 0xa3, 0xa3, 0xa3, 0x80, 0xdf, 0x90, 0x38, 0x04, 0x78, 0x52, 0x12, 0x0b, 0xfd, 0x90, //0x86d0,
    0x38, 0x00, 0xe0, 0xfe, 0xa3, 0xe0, 0xfd, 0xed, 0xff, 0xc3, 0x12, 0x0b, 0x9e, 0x90, 0x38, 0x10, //0x86e0,
    0x12, 0x0b, 0x92, 0x90, 0x38, 0x06, 0x78, 0x54, 0x12, 0x0b, 0xfd, 0x90, 0x38, 0x02, 0xe0, 0xfe, //0x86f0,
    0xa3, 0xe0, 0xfd, 0xed, 0xff, 0xc3, 0x12, 0x0b, 0x9e, 0x90, 0x38, 0x12, 0x12, 0x0b, 0x92, 0xa3, //0x8700,
    0xe0, 0xb4, 0x31, 0x07, 0x78, 0x52, 0x79, 0x52, 0x12, 0x0c, 0x13, 0x90, 0x38, 0x14, 0xe0, 0xb4, //0x8710,
    0x71, 0x15, 0x78, 0x52, 0xe6, 0xfe, 0x08, 0xe6, 0x78, 0x02, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, //0x8720,
    0xf9, 0x79, 0x53, 0xf7, 0xee, 0x19, 0xf7, 0x90, 0x38, 0x15, 0xe0, 0xb4, 0x31, 0x07, 0x78, 0x54, //0x8730,
    0x79, 0x54, 0x12, 0x0c, 0x13, 0x90, 0x38, 0x15, 0xe0, 0xb4, 0x71, 0x15, 0x78, 0x54, 0xe6, 0xfe, //0x8740,
    0x08, 0xe6, 0x78, 0x02, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x79, 0x55, 0xf7, 0xee, 0x19, //0x8750,
    0xf7, 0x79, 0x52, 0x12, 0x0b, 0xd9, 0x09, 0x12, 0x0b, 0xd9, 0xaf, 0x47, 0x12, 0x0b, 0xb2, 0xe5, //0x8760,
    0x44, 0xfb, 0x7a, 0x00, 0xfd, 0x7c, 0x00, 0x12, 0x04, 0xd3, 0x78, 0x5a, 0xa6, 0x06, 0x08, 0xa6, //0x8770,
    0x07, 0xaf, 0x45, 0x12, 0x0b, 0xb2, 0xad, 0x03, 0x7c, 0x00, 0x12, 0x04, 0xd3, 0x78, 0x56, 0xa6, //0x8780,
    0x06, 0x08, 0xa6, 0x07, 0xaf, 0x48, 0x78, 0x54, 0x12, 0x0b, 0xb4, 0xe5, 0x43, 0xfb, 0xfd, 0x7c, //0x8790,
    0x00, 0x12, 0x04, 0xd3, 0x78, 0x5c, 0xa6, 0x06, 0x08, 0xa6, 0x07, 0xaf, 0x46, 0x7e, 0x00, 0x78, //0x87a0,
    0x54, 0x12, 0x0b, 0xb6, 0xad, 0x03, 0x7c, 0x00, 0x12, 0x04, 0xd3, 0x78, 0x58, 0xa6, 0x06, 0x08, //0x87b0,
    0xa6, 0x07, 0xc3, 0x78, 0x5b, 0xe6, 0x94, 0x08, 0x18, 0xe6, 0x94, 0x00, 0x50, 0x05, 0x76, 0x00, //0x87c0,
    0x08, 0x76, 0x08, 0xc3, 0x78, 0x5d, 0xe6, 0x94, 0x08, 0x18, 0xe6, 0x94, 0x00, 0x50, 0x05, 0x76, //0x87d0,
    0x00, 0x08, 0x76, 0x08, 0x78, 0x5a, 0x12, 0x0b, 0xc6, 0xff, 0xd3, 0x78, 0x57, 0xe6, 0x9f, 0x18, //0x87e0,
    0xe6, 0x9e, 0x40, 0x0e, 0x78, 0x5a, 0xe6, 0x13, 0xfe, 0x08, 0xe6, 0x78, 0x57, 0x12, 0x0c, 0x08, //0x87f0,
    0x80, 0x04, 0x7e, 0x00, 0x7f, 0x00, 0x78, 0x5e, 0x12, 0x0b, 0xbe, 0xff, 0xd3, 0x78, 0x59, 0xe6, //0x8800,
    0x9f, 0x18, 0xe6, 0x9e, 0x40, 0x0e, 0x78, 0x5c, 0xe6, 0x13, 0xfe, 0x08, 0xe6, 0x78, 0x59, 0x12, //0x8810,
    0x0c, 0x08, 0x80, 0x04, 0x7e, 0x00, 0x7f, 0x00, 0xe4, 0xfc, 0xfd, 0x78, 0x62, 0x12, 0x06, 0x99, //0x8820,
    0x78, 0x5a, 0x12, 0x0b, 0xc6, 0x78, 0x57, 0x26, 0xff, 0xee, 0x18, 0x36, 0xfe, 0x78, 0x66, 0x12, //0x8830,
    0x0b, 0xbe, 0x78, 0x59, 0x26, 0xff, 0xee, 0x18, 0x36, 0xfe, 0xe4, 0xfc, 0xfd, 0x78, 0x6a, 0x12, //0x8840,
    0x06, 0x99, 0x12, 0x0b, 0xce, 0x78, 0x66, 0x12, 0x06, 0x8c, 0xd3, 0x12, 0x06, 0x45, 0x40, 0x08, //0x8850,
    0x12, 0x0b, 0xce, 0x78, 0x66, 0x12, 0x06, 0x99, 0x78, 0x54, 0x12, 0x0b, 0xd0, 0x78, 0x6a, 0x12, //0x8860,
    0x06, 0x8c, 0xd3, 0x12, 0x06, 0x45, 0x40, 0x0a, 0x78, 0x54, 0x12, 0x0b, 0xd0, 0x78, 0x6a, 0x12, //0x8870,
    0x06, 0x99, 0x78, 0x61, 0xe6, 0x90, 0x60, 0x01, 0xf0, 0x78, 0x65, 0xe6, 0xa3, 0xf0, 0x78, 0x69, //0x8880,
    0xe6, 0xa3, 0xf0, 0x78, 0x55, 0xe6, 0xa3, 0xf0, 0x7d, 0x01, 0x78, 0x61, 0x12, 0x0b, 0xe9, 0x24, //0x8890,
    0x01, 0x12, 0x0b, 0xa6, 0x78, 0x65, 0x12, 0x0b, 0xe9, 0x24, 0x02, 0x12, 0x0b, 0xa6, 0x78, 0x69, //0x88a0,
    0x12, 0x0b, 0xe9, 0x24, 0x03, 0x12, 0x0b, 0xa6, 0x78, 0x6d, 0x12, 0x0b, 0xe9, 0x24, 0x04, 0x12, //0x88b0,
    0x0b, 0xa6, 0x0d, 0xbd, 0x05, 0xd4, 0xc2, 0x0e, 0xc2, 0x06, 0x22, 0x85, 0x08, 0x41, 0x90, 0x30, //0x88c0,
    0x24, 0xe0, 0xf5, 0x3d, 0xa3, 0xe0, 0xf5, 0x3e, 0xa3, 0xe0, 0xf5, 0x3f, 0xa3, 0xe0, 0xf5, 0x40, //0x88d0,
    0xa3, 0xe0, 0xf5, 0x3c, 0xd2, 0x34, 0xe5, 0x41, 0x12, 0x06, 0xb1, 0x09, 0x31, 0x03, 0x09, 0x35, //0x88e0,
    0x04, 0x09, 0x3b, 0x05, 0x09, 0x3e, 0x06, 0x09, 0x41, 0x07, 0x09, 0x4a, 0x08, 0x09, 0x5b, 0x12, //0x88f0,
    0x09, 0x73, 0x18, 0x09, 0x89, 0x19, 0x09, 0x5e, 0x1a, 0x09, 0x6a, 0x1b, 0x09, 0xad, 0x80, 0x09, //0x8900,
    0xb2, 0x81, 0x0a, 0x1d, 0x8f, 0x0a, 0x09, 0x90, 0x0a, 0x1d, 0x91, 0x0a, 0x1d, 0x92, 0x0a, 0x1d, //0x8910,
    0x93, 0x0a, 0x1d, 0x94, 0x0a, 0x1d, 0x98, 0x0a, 0x17, 0x9f, 0x0a, 0x1a, 0xec, 0x00, 0x00, 0x0a, //0x8920,
    0x38, 0x12, 0x0f, 0x74, 0x22, 0x12, 0x0f, 0x74, 0xd2, 0x03, 0x22, 0xd2, 0x03, 0x22, 0xc2, 0x03, //0x8930,
    0x22, 0xa2, 0x37, 0xe4, 0x33, 0xf5, 0x3c, 0x02, 0x0a, 0x1d, 0xc2, 0x01, 0xc2, 0x02, 0xc2, 0x03, //0x8940,
    0x12, 0x0d, 0x0d, 0x75, 0x1e, 0x70, 0xd2, 0x35, 0x02, 0x0a, 0x1d, 0x02, 0x0a, 0x04, 0x85, 0x40, //0x8950,
    0x4a, 0x85, 0x3c, 0x4b, 0x12, 0x0a, 0xff, 0x02, 0x0a, 0x1d, 0x85, 0x4a, 0x40, 0x85, 0x4b, 0x3c, //0x8960,
    0x02, 0x0a, 0x1d, 0xe4, 0xf5, 0x22, 0xf5, 0x23, 0x85, 0x40, 0x31, 0x85, 0x3f, 0x30, 0x85, 0x3e, //0x8970,
    0x2f, 0x85, 0x3d, 0x2e, 0x12, 0x0f, 0x46, 0x80, 0x1f, 0x75, 0x22, 0x00, 0x75, 0x23, 0x01, 0x74, //0x8980,
    0xff, 0xf5, 0x2d, 0xf5, 0x2c, 0xf5, 0x2b, 0xf5, 0x2a, 0x12, 0x0f, 0x46, 0x85, 0x2d, 0x40, 0x85, //0x8990,
    0x2c, 0x3f, 0x85, 0x2b, 0x3e, 0x85, 0x2a, 0x3d, 0xe4, 0xf5, 0x3c, 0x80, 0x70, 0x12, 0x0f, 0x16, //0x89a0,
    0x80, 0x6b, 0x85, 0x3d, 0x45, 0x85, 0x3e, 0x46, 0xe5, 0x47, 0xc3, 0x13, 0xff, 0xe5, 0x45, 0xc3, //0x89b0,
    0x9f, 0x50, 0x02, 0x8f, 0x45, 0xe5, 0x48, 0xc3, 0x13, 0xff, 0xe5, 0x46, 0xc3, 0x9f, 0x50, 0x02, //0x89c0,
    0x8f, 0x46, 0xe5, 0x47, 0xc3, 0x13, 0xff, 0xfd, 0xe5, 0x45, 0x2d, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, //0x89d0,
    0x44, 0x12, 0x0f, 0x90, 0x40, 0x05, 0xe5, 0x44, 0x9f, 0xf5, 0x45, 0xe5, 0x48, 0xc3, 0x13, 0xff, //0x89e0,
    0xfd, 0xe5, 0x46, 0x2d, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x43, 0x12, 0x0f, 0x90, 0x40, 0x05, 0xe5, //0x89f0,
    0x43, 0x9f, 0xf5, 0x46, 0x12, 0x06, 0xd7, 0x80, 0x14, 0x85, 0x40, 0x48, 0x85, 0x3f, 0x47, 0x85, //0x8a00,
    0x3e, 0x46, 0x85, 0x3d, 0x45, 0x80, 0x06, 0x02, 0x06, 0xd7, 0x12, 0x0d, 0x7e, 0x90, 0x30, 0x24, //0x8a10,
    0xe5, 0x3d, 0xf0, 0xa3, 0xe5, 0x3e, 0xf0, 0xa3, 0xe5, 0x3f, 0xf0, 0xa3, 0xe5, 0x40, 0xf0, 0xa3, //0x8a20,
    0xe5, 0x3c, 0xf0, 0x90, 0x30, 0x23, 0xe4, 0xf0, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0xc0, //0x8a30,
    0xd0, 0x90, 0x3f, 0x0c, 0xe0, 0xf5, 0x32, 0xe5, 0x32, 0x30, 0xe3, 0x74, 0x30, 0x36, 0x66, 0x90, //0x8a40,
    0x60, 0x19, 0xe0, 0xf5, 0x0a, 0xa3, 0xe0, 0xf5, 0x0b, 0x90, 0x60, 0x1d, 0xe0, 0xf5, 0x14, 0xa3, //0x8a50,
    0xe0, 0xf5, 0x15, 0x90, 0x60, 0x21, 0xe0, 0xf5, 0x0c, 0xa3, 0xe0, 0xf5, 0x0d, 0x90, 0x60, 0x29, //0x8a60,
    0xe0, 0xf5, 0x0e, 0xa3, 0xe0, 0xf5, 0x0f, 0x90, 0x60, 0x31, 0xe0, 0xf5, 0x10, 0xa3, 0xe0, 0xf5, //0x8a70,
    0x11, 0x90, 0x60, 0x39, 0xe0, 0xf5, 0x12, 0xa3, 0xe0, 0xf5, 0x13, 0x30, 0x01, 0x06, 0x30, 0x33, //0x8a80,
    0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x09, 0x30, 0x02, 0x06, 0x30, 0x33, 0x03, 0xd3, 0x80, 0x01, //0x8a90,
    0xc3, 0x92, 0x0a, 0x30, 0x33, 0x0c, 0x30, 0x03, 0x09, 0x20, 0x02, 0x06, 0x20, 0x01, 0x03, 0xd3, //0x8aa0,
    0x80, 0x01, 0xc3, 0x92, 0x0b, 0x90, 0x30, 0x01, 0xe0, 0x44, 0x40, 0xf0, 0xe0, 0x54, 0xbf, 0xf0, //0x8ab0,
    0xe5, 0x32, 0x30, 0xe1, 0x14, 0x30, 0x34, 0x11, 0x90, 0x30, 0x22, 0xe0, 0xf5, 0x08, 0xe4, 0xf0, //0x8ac0,
    0x30, 0x00, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x08, 0xe5, 0x32, 0x30, 0xe5, 0x12, 0x90, 0x56, //0x8ad0,
    0xa1, 0xe0, 0xf5, 0x09, 0x30, 0x31, 0x09, 0x30, 0x05, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x92, 0x0d, //0x8ae0,
    0x90, 0x3f, 0x0c, 0xe5, 0x32, 0xf0, 0xd0, 0xd0, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, //0x8af0,
    0x0e, 0x7e, 0xe4, 0x93, 0xfe, 0x74, 0x01, 0x93, 0xff, 0xc3, 0x90, 0x0e, 0x7c, 0x74, 0x01, 0x93, //0x8b00,
    0x9f, 0xff, 0xe4, 0x93, 0x9e, 0xfe, 0xe4, 0x8f, 0x3b, 0x8e, 0x3a, 0xf5, 0x39, 0xf5, 0x38, 0xab, //0x8b10,
    0x3b, 0xaa, 0x3a, 0xa9, 0x39, 0xa8, 0x38, 0xaf, 0x4b, 0xfc, 0xfd, 0xfe, 0x12, 0x05, 0x28, 0x12, //0x8b20,
    0x0d, 0xe1, 0xe4, 0x7b, 0xff, 0xfa, 0xf9, 0xf8, 0x12, 0x05, 0xb3, 0x12, 0x0d, 0xe1, 0x90, 0x0e, //0x8b30,
    0x69, 0xe4, 0x12, 0x0d, 0xf6, 0x12, 0x0d, 0xe1, 0xe4, 0x85, 0x4a, 0x37, 0xf5, 0x36, 0xf5, 0x35, //0x8b40,
    0xf5, 0x34, 0xaf, 0x37, 0xae, 0x36, 0xad, 0x35, 0xac, 0x34, 0xa3, 0x12, 0x0d, 0xf6, 0x8f, 0x37, //0x8b50,
    0x8e, 0x36, 0x8d, 0x35, 0x8c, 0x34, 0xe5, 0x3b, 0x45, 0x37, 0xf5, 0x3b, 0xe5, 0x3a, 0x45, 0x36, //0x8b60,
    0xf5, 0x3a, 0xe5, 0x39, 0x45, 0x35, 0xf5, 0x39, 0xe5, 0x38, 0x45, 0x34, 0xf5, 0x38, 0xe4, 0xf5, //0x8b70,
    0x22, 0xf5, 0x23, 0x85, 0x3b, 0x31, 0x85, 0x3a, 0x30, 0x85, 0x39, 0x2f, 0x85, 0x38, 0x2e, 0x02, //0x8b80,
    0x0f, 0x46, 0xe0, 0xa3, 0xe0, 0x75, 0xf0, 0x02, 0xa4, 0xff, 0xae, 0xf0, 0xc3, 0x08, 0xe6, 0x9f, //0x8b90,
    0xf6, 0x18, 0xe6, 0x9e, 0xf6, 0x22, 0xff, 0xe5, 0xf0, 0x34, 0x60, 0x8f, 0x82, 0xf5, 0x83, 0xec, //0x8ba0,
    0xf0, 0x22, 0x78, 0x52, 0x7e, 0x00, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x02, 0x04, 0xc1, 0xe4, 0xfc, //0x8bb0,
    0xfd, 0x12, 0x06, 0x99, 0x78, 0x5c, 0xe6, 0xc3, 0x13, 0xfe, 0x08, 0xe6, 0x13, 0x22, 0x78, 0x52, //0x8bc0,
    0xe6, 0xfe, 0x08, 0xe6, 0xff, 0xe4, 0xfc, 0xfd, 0x22, 0xe7, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0x68, //0x8bd0,
    0xf7, 0x09, 0xe7, 0xc4, 0x54, 0x0f, 0x48, 0xf7, 0x22, 0xe6, 0xfc, 0xed, 0x75, 0xf0, 0x04, 0xa4, //0x8be0,
    0x22, 0x12, 0x06, 0x7c, 0x8f, 0x48, 0x8e, 0x47, 0x8d, 0x46, 0x8c, 0x45, 0x22, 0xe0, 0xfe, 0xa3, //0x8bf0,
    0xe0, 0xfd, 0xee, 0xf6, 0xed, 0x08, 0xf6, 0x22, 0x13, 0xff, 0xc3, 0xe6, 0x9f, 0xff, 0x18, 0xe6, //0x8c00,
    0x9e, 0xfe, 0x22, 0xe6, 0xc3, 0x13, 0xf7, 0x08, 0xe6, 0x13, 0x09, 0xf7, 0x22, 0xad, 0x39, 0xac, //0x8c10,
    0x38, 0xfa, 0xf9, 0xf8, 0x12, 0x05, 0x28, 0x8f, 0x3b, 0x8e, 0x3a, 0x8d, 0x39, 0x8c, 0x38, 0xab, //0x8c20,
    0x37, 0xaa, 0x36, 0xa9, 0x35, 0xa8, 0x34, 0x22, 0x93, 0xff, 0xe4, 0xfc, 0xfd, 0xfe, 0x12, 0x05, //0x8c30,
    0x28, 0x8f, 0x37, 0x8e, 0x36, 0x8d, 0x35, 0x8c, 0x34, 0x22, 0x78, 0x84, 0xe6, 0xfe, 0x08, 0xe6, //0x8c40,
    0xff, 0xe4, 0x8f, 0x37, 0x8e, 0x36, 0xf5, 0x35, 0xf5, 0x34, 0x22, 0x90, 0x0e, 0x8c, 0xe4, 0x93, //0x8c50,
    0x25, 0xe0, 0x24, 0x0a, 0xf8, 0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x22, 0xe6, 0xfe, 0x08, 0xe6, 0xff, //0x8c60,
    0xe4, 0x8f, 0x3b, 0x8e, 0x3a, 0xf5, 0x39, 0xf5, 0x38, 0x22, 0x78, 0x4e, 0xe6, 0xfe, 0x08, 0xe6, //0x8c70,
    0xff, 0x22, 0xef, 0x25, 0xe0, 0x24, 0x4e, 0xf8, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x22, 0x78, 0x89, //0x8c80,
    0xef, 0x26, 0xf6, 0x18, 0xe4, 0x36, 0xf6, 0x22, 0x75, 0x89, 0x03, 0x75, 0xa8, 0x01, 0x75, 0xb8, //0x8c90,
    0x04, 0x75, 0x34, 0xff, 0x75, 0x35, 0x0e, 0x75, 0x36, 0x15, 0x75, 0x37, 0x0d, 0x12, 0x0e, 0x9a, //0x8ca0,
    0x12, 0x00, 0x09, 0x12, 0x0f, 0x16, 0x12, 0x00, 0x06, 0xd2, 0x00, 0xd2, 0x34, 0xd2, 0xaf, 0x75, //0x8cb0,
    0x34, 0xff, 0x75, 0x35, 0x0e, 0x75, 0x36, 0x49, 0x75, 0x37, 0x03, 0x12, 0x0e, 0x9a, 0x30, 0x08, //0x8cc0,
    0x09, 0xc2, 0x34, 0x12, 0x08, 0xcb, 0xc2, 0x08, 0xd2, 0x34, 0x30, 0x0b, 0x09, 0xc2, 0x36, 0x12, //0x8cd0,
    0x02, 0x6c, 0xc2, 0x0b, 0xd2, 0x36, 0x30, 0x09, 0x09, 0xc2, 0x36, 0x12, 0x00, 0x0e, 0xc2, 0x09, //0x8ce0,
    0xd2, 0x36, 0x30, 0x0e, 0x03, 0x12, 0x06, 0xd7, 0x30, 0x35, 0xd3, 0x90, 0x30, 0x29, 0xe5, 0x1e, //0x8cf0,
    0xf0, 0xb4, 0x10, 0x05, 0x90, 0x30, 0x23, 0xe4, 0xf0, 0xc2, 0x35, 0x80, 0xc1, 0xe4, 0xf5, 0x4b, //0x8d00,
    0x90, 0x0e, 0x7a, 0x93, 0xff, 0xe4, 0x8f, 0x37, 0xf5, 0x36, 0xf5, 0x35, 0xf5, 0x34, 0xaf, 0x37, //0x8d10,
    0xae, 0x36, 0xad, 0x35, 0xac, 0x34, 0x90, 0x0e, 0x6a, 0x12, 0x0d, 0xf6, 0x8f, 0x37, 0x8e, 0x36, //0x8d20,
    0x8d, 0x35, 0x8c, 0x34, 0x90, 0x0e, 0x72, 0x12, 0x06, 0x7c, 0xef, 0x45, 0x37, 0xf5, 0x37, 0xee, //0x8d30,
    0x45, 0x36, 0xf5, 0x36, 0xed, 0x45, 0x35, 0xf5, 0x35, 0xec, 0x45, 0x34, 0xf5, 0x34, 0xe4, 0xf5, //0x8d40,
    0x22, 0xf5, 0x23, 0x85, 0x37, 0x31, 0x85, 0x36, 0x30, 0x85, 0x35, 0x2f, 0x85, 0x34, 0x2e, 0x12, //0x8d50,
    0x0f, 0x46, 0xe4, 0xf5, 0x22, 0xf5, 0x23, 0x90, 0x0e, 0x72, 0x12, 0x0d, 0xea, 0x12, 0x0f, 0x46, //0x8d60,
    0xe4, 0xf5, 0x22, 0xf5, 0x23, 0x90, 0x0e, 0x6e, 0x12, 0x0d, 0xea, 0x02, 0x0f, 0x46, 0xe5, 0x40, //0x8d70,
    0x24, 0xf2, 0xf5, 0x37, 0xe5, 0x3f, 0x34, 0x43, 0xf5, 0x36, 0xe5, 0x3e, 0x34, 0xa2, 0xf5, 0x35, //0x8d80,
    0xe5, 0x3d, 0x34, 0x28, 0xf5, 0x34, 0xe5, 0x37, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 0x78, 0x18, 0x12, //0x8d90,
    0x06, 0x69, 0x8f, 0x40, 0x8e, 0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0xe5, 0x37, 0x54, 0xa0, 0xff, 0xe5, //0x8da0,
    0x36, 0xfe, 0xe4, 0xfd, 0xfc, 0x78, 0x07, 0x12, 0x06, 0x56, 0x78, 0x10, 0x12, 0x0f, 0x9a, 0xe4, //0x8db0,
    0xff, 0xfe, 0xe5, 0x35, 0xfd, 0xe4, 0xfc, 0x78, 0x0e, 0x12, 0x06, 0x56, 0x12, 0x0f, 0x9d, 0xe4, //0x8dc0,
    0xff, 0xfe, 0xfd, 0xe5, 0x34, 0xfc, 0x78, 0x18, 0x12, 0x06, 0x56, 0x78, 0x08, 0x12, 0x0f, 0x9a, //0x8dd0,
    0x22, 0x8f, 0x3b, 0x8e, 0x3a, 0x8d, 0x39, 0x8c, 0x38, 0x22, 0x12, 0x06, 0x7c, 0x8f, 0x31, 0x8e, //0x8de0,
    0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0x22, 0x93, 0xf9, 0xf8, 0x02, 0x06, 0x69, 0x00, 0x00, 0x00, 0x00, //0x8df0,
    0x12, 0x01, 0x17, 0x08, 0x31, 0x15, 0x53, 0x54, 0x44, 0x20, 0x20, 0x20, 0x20, 0x20, 0x13, 0x01, //0x8e00,
    0x10, 0x01, 0x56, 0x40, 0x1a, 0x30, 0x29, 0x7e, 0x00, 0x30, 0x04, 0x20, 0xdf, 0x30, 0x05, 0x40, //0x8e10,
    0xbf, 0x50, 0x03, 0x00, 0xfd, 0x50, 0x27, 0x01, 0xfe, 0x60, 0x00, 0x11, 0x00, 0x3f, 0x05, 0x30, //0x8e20,
    0x00, 0x3f, 0x06, 0x22, 0x00, 0x3f, 0x01, 0x2a, 0x00, 0x3f, 0x02, 0x00, 0x00, 0x36, 0x06, 0x07, //0x8e30,
    0x00, 0x3f, 0x0b, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x01, 0x40, 0xbf, 0x30, 0x01, 0x00, //0x8e40,
    0xbf, 0x30, 0x29, 0x70, 0x00, 0x3a, 0x00, 0x00, 0xff, 0x3a, 0x00, 0x00, 0xff, 0x36, 0x03, 0x36, //0x8e50,
    0x02, 0x41, 0x44, 0x58, 0x20, 0x18, 0x10, 0x0a, 0x04, 0x04, 0x00, 0x03, 0xff, 0x64, 0x00, 0x00, //0x8e60,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x06, 0x00, 0x03, 0x51, 0x00, 0x7a, //0x8e70,
    0x50, 0x3c, 0x28, 0x1e, 0x10, 0x10, 0x50, 0x2d, 0x28, 0x16, 0x10, 0x10, 0x02, 0x00, 0x10, 0x0c, //0x8e80,
    0x10, 0x04, 0x0c, 0x6e, 0x06, 0x05, 0x00, 0xa5, 0x5a, 0x00, 0xae, 0x35, 0xaf, 0x36, 0xe4, 0xfd, //0x8e90,
    0xed, 0xc3, 0x95, 0x37, 0x50, 0x33, 0x12, 0x0f, 0xe2, 0xe4, 0x93, 0xf5, 0x38, 0x74, 0x01, 0x93, //0x8ea0,
    0xf5, 0x39, 0x45, 0x38, 0x60, 0x23, 0x85, 0x39, 0x82, 0x85, 0x38, 0x83, 0xe0, 0xfc, 0x12, 0x0f, //0x8eb0,
    0xe2, 0x74, 0x03, 0x93, 0x52, 0x04, 0x12, 0x0f, 0xe2, 0x74, 0x02, 0x93, 0x42, 0x04, 0x85, 0x39, //0x8ec0,
    0x82, 0x85, 0x38, 0x83, 0xec, 0xf0, 0x0d, 0x80, 0xc7, 0x22, 0x78, 0xbe, 0xe6, 0xd3, 0x08, 0xff, //0x8ed0,
    0xe6, 0x64, 0x80, 0xf8, 0xef, 0x64, 0x80, 0x98, 0x22, 0x93, 0xff, 0x7e, 0x00, 0xe6, 0xfc, 0x08, //0x8ee0,
    0xe6, 0xfd, 0x12, 0x04, 0xc1, 0x78, 0xc1, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0xd3, 0xef, 0x9d, 0xee, //0x8ef0,
    0x9c, 0x22, 0x78, 0xbd, 0xd3, 0xe6, 0x64, 0x80, 0x94, 0x80, 0x22, 0x25, 0xe0, 0x24, 0x0a, 0xf8, //0x8f00,
    0xe6, 0xfe, 0x08, 0xe6, 0xff, 0x22, 0xe5, 0x3c, 0xd3, 0x94, 0x00, 0x40, 0x0b, 0x90, 0x0e, 0x88, //0x8f10,
    0x12, 0x0b, 0xf1, 0x90, 0x0e, 0x86, 0x80, 0x09, 0x90, 0x0e, 0x82, 0x12, 0x0b, 0xf1, 0x90, 0x0e, //0x8f20,
    0x80, 0xe4, 0x93, 0xf5, 0x44, 0xa3, 0xe4, 0x93, 0xf5, 0x43, 0xd2, 0x06, 0x30, 0x06, 0x03, 0xd3, //0x8f30,
    0x80, 0x01, 0xc3, 0x92, 0x0e, 0x22, 0xa2, 0xaf, 0x92, 0x32, 0xc2, 0xaf, 0xe5, 0x23, 0x45, 0x22, //0x8f40,
    0x90, 0x0e, 0x5d, 0x60, 0x0e, 0x12, 0x0f, 0xcb, 0xe0, 0xf5, 0x2c, 0x12, 0x0f, 0xc8, 0xe0, 0xf5, //0x8f50,
    0x2d, 0x80, 0x0c, 0x12, 0x0f, 0xcb, 0xe5, 0x30, 0xf0, 0x12, 0x0f, 0xc8, 0xe5, 0x31, 0xf0, 0xa2, //0x8f60,
    0x32, 0x92, 0xaf, 0x22, 0xd2, 0x01, 0xc2, 0x02, 0xe4, 0xf5, 0x1f, 0xf5, 0x1e, 0xd2, 0x35, 0xd2, //0x8f70,
    0x33, 0xd2, 0x36, 0xd2, 0x01, 0xc2, 0x02, 0xf5, 0x1f, 0xf5, 0x1e, 0xd2, 0x35, 0xd2, 0x33, 0x22, //0x8f80,
    0xfb, 0xd3, 0xed, 0x9b, 0x74, 0x80, 0xf8, 0x6c, 0x98, 0x22, 0x12, 0x06, 0x69, 0xe5, 0x40, 0x2f, //0x8f90,
    0xf5, 0x40, 0xe5, 0x3f, 0x3e, 0xf5, 0x3f, 0xe5, 0x3e, 0x3d, 0xf5, 0x3e, 0xe5, 0x3d, 0x3c, 0xf5, //0x8fa0,
    0x3d, 0x22, 0xc0, 0xe0, 0xc0, 0x83, 0xc0, 0x82, 0x90, 0x3f, 0x0d, 0xe0, 0xf5, 0x33, 0xe5, 0x33, //0x8fb0,
    0xf0, 0xd0, 0x82, 0xd0, 0x83, 0xd0, 0xe0, 0x32, 0x90, 0x0e, 0x5f, 0xe4, 0x93, 0xfe, 0x74, 0x01, //0x8fc0,
    0x93, 0xf5, 0x82, 0x8e, 0x83, 0x22, 0x78, 0x7f, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x81, 0xcd, 0x02, //0x8fd0,
    0x0c, 0x98, 0x8f, 0x82, 0x8e, 0x83, 0x75, 0xf0, 0x04, 0xed, 0x02, 0x06, 0xa5, //0x8fe0
};

static  struct ov5640_win_size ov5640_wins[] = {
{
    .name    = "VGA",    /* VGA: 640*480 */
    .resv    = RESV_VGA,
    .width   = VGA_WIDTH,
    .height  = VGA_HEIGHT,
    .regs    = ov5640_qsxga_to_vga_regs,
},
{
    .name    = "XGA",    /* XGA: 1024*768 */
    .resv    = RESV_XGA,
    .width   = XGA_WIDTH,
    .height  = XGA_HEIGHT,
    .regs    = ov5640_qsxga_to_xga_regs,
},
{
    .name    = "SXGA",    /* SXGA: 1280*960  */
    .resv    = RESV_SXGA,
    .width   = SXGA_WIDTH,
    .height  = SXGA_HEIGHT,
    .regs    = ov5640_qsxga_to_sxga_regs,
},
{
    .name    = "UXGA",    /* UXGA: 1600*1200 */
    .resv    = RESV_UXGA,
    .width   = UXGA_WIDTH,
    .height  = UXGA_HEIGHT,
    .regs    = ov5640_qsxga_to_uxga_regs,
},
{
    .name    = "QXGA",    /* QXGA: 2048*1536 */
    .resv    = RESV_QXGA,
    .width   = QXGA_WIDTH,
    .height  = QXGA_HEIGHT,
    .regs    = ov5640_qsxga_to_qxga_regs,
},
{
    .name    = "QSXGA",    /* QSXGA: 2560*1920*/
    .resv    = RESV_QSXGA,
    .width   = QSXGA_WIDTH,
    .height  = QSXGA_HEIGHT,
    .regs    = ov5640_qsxga_regs,
},

};



static int ov5640_sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
                              unsigned char *value)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    u8 data[REG_STEP];
    struct i2c_msg msg;
    int ret,i;

    for(i = 0; i < REG_ADDR_STEP; i++)
        data[i] = reg[i];

    for(i = REG_ADDR_STEP; i < REG_STEP; i++)
        data[i] = 0xff;
    /*
         * Send out the register address...
         */
    msg.addr = client->addr;
    msg.flags = 0;
    msg.len = REG_ADDR_STEP;
    msg.buf = data;
    ret = i2c_transfer(client->adapter, &msg, 1);
    if (ret < 0) {
        csi_dev_err("Error %d on register write\n", ret);
        return ret;
    }
    /*
         * ...then read back the result.
         */

    msg.flags = I2C_M_RD;
    msg.len = REG_DATA_STEP;
    msg.buf = &data[REG_ADDR_STEP];

    ret = i2c_transfer(client->adapter, &msg, 1);
    if (ret >= 0) {
        for(i = 0; i < REG_DATA_STEP; i++)
            value[i] = data[i+REG_ADDR_STEP];
        ret = 0;
    }
    else {
        csi_dev_err("Error %d on register read\n", ret);
    }
    return ret;
}

static int ov5640_sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
                               unsigned char *value)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct i2c_msg msg;
    unsigned char data[REG_STEP];
    int ret,i;

    for(i = 0; i < REG_ADDR_STEP; i++)
        data[i] = reg[i];
    for(i = REG_ADDR_STEP; i < REG_STEP; i++)
        data[i] = value[i-REG_ADDR_STEP];

    msg.addr = client->addr;
    msg.flags = 0;
    msg.len = REG_STEP;
    msg.buf = data;


    ret = i2c_transfer(client->adapter, &msg, 1);
    if (ret > 0) {
        ret = 0;
    }
    else if (ret < 0) {
        csi_dev_print("addr = 0x%4x, value = 0x%2x\n ",reg[0]*256+reg[1],value[0]);
        csi_dev_err("sensor_write error!\n");
    }
    return ret;
}
static int ov5640_sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
{
    int i,ret;
    unsigned int cnt;
    //	unsigned char rd;
    if (size == 0)
        return -EINVAL;

    for(i = 0; i < size ; i++)
    {
        if(vals->reg_num[0] == 0xff && vals->reg_num[1] == 0xff) {
            mdelay(vals->value[0]);
        }
        else {
            cnt=0;
            ret = ov5640_sensor_write(sd, vals->reg_num, vals->value);
            while( ret < 0 && cnt < 3)
            {
                if(ret<0)
                    csi_dev_err("sensor_write_err!\n");
                ret = ov5640_sensor_write(sd, vals->reg_num, vals->value);
                cnt++;
            }
            if(cnt>0)
                csi_dev_err("csi i2c retry cnt=%d\n",cnt);

            if(ret<0 && cnt >=3)
                return ret;
        }
        vals++;
    }

    return 0;
}


static int ov5640_sensor_write_continuous(struct v4l2_subdev *sd, int addr, char vals[] , uint size)
{
    int i,ret;
    struct regval_list reg_addr;

    if (size == 0)
        return -EINVAL;

    for(i = 0; i < size ; i++)
    {
        reg_addr.reg_num[0] = (addr&0xff00)>>8;
        reg_addr.reg_num[1] = (addr&0x00ff);

        ret = ov5640_sensor_write(sd, reg_addr.reg_num, &vals[i]);
        if (ret < 0)
        {
            csi_dev_err("sensor_write_err!\n");
            return ret;
        }
        addr++;
    }

    return 0;
}


static inline struct ov5640_priv *to_ov5640(const struct i2c_client *client)
{
    return container_of(i2c_get_clientdata(client), struct ov5640_priv, subdev);
}

static int reset_ov5640(struct i2c_client *client)
{
    int ret = i2cc_set_reg(client, 0x3008, 0x82);
    mdelay(5);
    return (ret);
}

static int write_regs(struct i2c_client *client, const struct regval *regs, int array_len)
{
    int i;
    int ret = 0;

    for (i = 0; i < array_len; i++) {
        if ((ret = i2cc_set_reg(client, regs->reg, regs->val))) {
            OV_ERR("error to set reg:0x%d -> value:%d(index:%d)\n", regs->reg,
                   regs->val, i);
            return -1;
        }
        regs++;
    }

    //    INFO_BLUE("------*------- write array regs over -------*------ \n");

    return (ret);
}

static int write_regs_flags(struct i2c_client *client,  const struct regval *regs)
{
    int i;
    int ret = 0;

  while (regs->reg != 0xff)
  {
        if ((ret = i2cc_set_reg(client, regs->reg, regs->val))) {
            OV_ERR("error to set reg:0x%d -> value:%d(index:%d)\n", regs->reg,
                   regs->val, i);
            return -1;
        }
        regs++;
    }

    //    INFO_BLUE("------*------- write array regs over -------*------ \n");

    return (ret);
}

static const struct ov5640_win_size *select_win(
        unsigned int width, unsigned int height)
{
    struct ov5640_win_size *win = NULL;
    int size = ARRAY_SIZE(ov5640_wins);
    unsigned int diff = -1;
    unsigned int tmp;
    int i;


    for (i = 0; i < ARRAY_SIZE(ov5640_wins); i++)
    {
        win = &ov5640_wins[i];
        if (width == win->width && height == win->height)
        {
             printk("%s  width=%d, height =%d\n",__func__,win->width,win->height);
             return win;
        }
    }

    printk(KERN_ERR "%s: unsupported width, height (%dx%d)\n", __func__, width, height);
    return NULL;

}





/* stuff about auto focus */
static int ov5640_sensor_download_af_fw(struct v4l2_subdev *sd)
{
    int ret,cnt;
    struct regval_list regs;
    struct regval_list af_fw_reset_reg[] = {
    {{0x30,0x00},{0x20}},
};
    struct regval_list af_fw_start_reg[] = {
    {{0x30,0x22},{0x00}},
    {{0x30,0x23},{0x00}},
    {{0x30,0x24},{0x00}},
    {{0x30,0x25},{0x00}},
    {{0x30,0x26},{0x00}},
    {{0x30,0x27},{0x00}},
    {{0x30,0x28},{0x00}},
    {{0x30,0x29},{0x7f}},//0x7f
    {{0x30,0x00},{0x00}},	//start firmware for af
};

    //reset sensor MCU
    ret = ov5640_sensor_write_array(sd, af_fw_reset_reg, ARRAY_SIZE(af_fw_reset_reg));
    if(ret < 0) {
        csi_dev_err("reset sensor MCU error\n");
        return ret;
    }

    //download af fw
    ret =ov5640_sensor_write_continuous(sd, 0x8000, ov5640_sensor_af_fw_regs, ARRAY_SIZE(ov5640_sensor_af_fw_regs));
    if(ret < 0) {
        csi_dev_err("download af fw error\n");
        return ret;
    }
    //start af firmware
    ret = ov5640_sensor_write_array(sd, af_fw_start_reg, ARRAY_SIZE(af_fw_start_reg));
    if(ret < 0) {
        csi_dev_err("start af firmware error\n");
        return ret;
    }

    mdelay(10);
    //check the af firmware status
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x29;
    regs.value[0] = 0xff;
    cnt = 0;
    while(regs.value[0]!=0x70) {
        mdelay(5);
        ret = ov5640_sensor_read(sd, regs.reg_num, regs.value);
        if (ret < 0)
        {
            csi_dev_err("sensor check the af firmware status err !\n");
            return ret;
        }
        cnt++;
        if(cnt > 200) {
            csi_dev_err("AF firmware check status time out !\n");
            return -EFAULT;
        }
    }
    csi_dev_print("AF firmware check status complete,0x3029 = 0x%x\n",regs.value[0]);

#if DEV_DBG_EN == 1
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x00;
    ov5640_sensor_read(sd, regs.reg_num, regs.value);
    csi_dev_print("0x3000 = 0x%x\n",regs.value[0]);

    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x04;
    ov5640_sensor_read(sd, regs.reg_num, regs.value);
    csi_dev_print("0x3004 = 0x%x\n",regs.value[0]);

    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x01;
    ov5640_sensor_read(sd, regs.reg_num, regs.value);
    csi_dev_print("0x3001 = 0x%x\n",regs.value[0]);

    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x05;
    ov5640_sensor_read(sd, regs.reg_num, regs.value);
    csi_dev_print("0x3005 = 0x%x\n",regs.value[0]);
#endif

    return 0;
}

static int ov5640_sensor_s_release_af(struct v4l2_subdev *sd)
{
    struct regval_list regs;
    int ret;
    //release focus
    csi_dev_print("sensor_s_release_af\n");

    //trig single af
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x22;
    regs.value[0] = 0x03;
    ret = ov5640_sensor_write(sd, regs.reg_num, regs.value);
    if (ret < 0)
    {
        csi_dev_err("sensor tigger single af err !\n");
        return ret;
    }
    //release single af
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x22;
    regs.value[0] = 0x08;
    ret = ov5640_sensor_write(sd, regs.reg_num, regs.value);
    if (ret < 0)
    {
        csi_dev_err("release focus err !\n");
        return ret;
    }
    return 0;
}

static int ov5640_sensor_s_af_zone(struct v4l2_subdev *sd, unsigned int xc, unsigned int yc)
{
    //struct sensor_info *info = to_state(sd);
    struct regval_list regs;
    int ret;

    csi_dev_print("sensor_s_af_zone\n");
    csi_dev_print("af zone input xc=%d,yc=%d\n",xc,yc);
#if 0
    if(info->width == 0 || info->height == 0) {
        csi_dev_err("current width or height is zero!\n");
        return -EINVAL;
    }
#endif
    xc = xc * 80 /640;

    yc = yc * 60 / 480;


    //csi_dev_dbg("af zone after xc=%d,yc=%d\n",xc,yc);

    //set x center
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x24;
    regs.value[0] = xc;
    ret = ov5640_sensor_write(sd, regs.reg_num, regs.value);
    if (ret < 0)
    {
        csi_dev_err("sensor_s_af_zone_xc error!\n");
        return ret;
    }
    //set y center
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x25;
    regs.value[0] = yc;
    ret = ov5640_sensor_write(sd, regs.reg_num, regs.value);
    if (ret < 0)
    {
        csi_dev_err("sensor_s_af_zone_yc error!\n");
        return ret;
    }

    //set af zone
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x22;
    regs.value[0] = 0x81;
    ret = ov5640_sensor_write(sd, regs.reg_num, regs.value);
    if (ret < 0)
    {
        csi_dev_err("sensor_s_af_zone error!\n");
        return ret;
    }
    mdelay(5);
    return 0;
}

static int ov5640_sensor_s_pause_af(struct v4l2_subdev *sd)
{
    struct regval_list regs;
    int ret;
    //pause af poisition
    csi_dev_print("sensor_s_pause_af\n");
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x22;
    regs.value[0] = 0x06;
    ret = ov5640_sensor_write(sd, regs.reg_num, regs.value);
    if (ret < 0)
    {
        csi_dev_err("sensor pause af err !\n");
        return ret;
    }
    mdelay(5);
    return 0;
}

static int ov5640_get_auto_focus_result(struct v4l2_subdev *sd,
                                        struct v4l2_control *ctrl)
{
    struct regval_list regs;
    int ret,cnt;

    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x23;
    regs.value[0] = 0xff;
    cnt = 0;
    while(regs.value[0]!=0x00)
    {
        mdelay(5);
        ret = ov5640_sensor_read(sd, regs.reg_num, regs.value);
        if (ret < 0)
        {
            ctrl->value = AUTO_FOCUS_FAILED;
            csi_dev_err("sensor get af status err !\n");
            return ret;
        }
        cnt++;
        if(cnt>1000) {
            ctrl->value = AUTO_FOCUS_FAILED;
            csi_dev_err("Single AF is timeout,value = 0x%x\n",regs.value[0]);
            return -EFAULT;
        }
    }

    ov5640_sensor_s_pause_af(sd);

    //ov5640_sensor_s_af_zone(sd, 640, 480);

    ctrl->value = AUTO_FOCUS_DONE;

    return 0;
}

static int ov5640_sensor_s_single_af(struct v4l2_subdev *sd)
{
    struct regval_list regs;
    int ret;
    csi_dev_print("sensor_s_single_af\n");
#if 1
    //trig single af
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x23;
    regs.value[0] = 0x01;
    ret = ov5640_sensor_write(sd, regs.reg_num, regs.value);
    if (ret < 0)
    {
        csi_dev_err("sensor tigger single af err !\n");
        return ret;
    }
#endif
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x22;
    regs.value[0] = 0x03;
    ret = ov5640_sensor_write(sd, regs.reg_num, regs.value);
    if (ret < 0)
    {
        csi_dev_err("sensor tigger single af err !\n");
        return ret;
    }
#if 0
    //wait for af complete
    regs.reg_num[0] = 0x30;
    regs.reg_num[1] = 0x23;
    regs.value[0] = 0xff;
    cnt = 0;
    while(regs.value[0]!=0x00)
    {
        mdelay(5);
        ret = ov5640_sensor_read(sd, regs.reg_num, regs.value);
        if (ret < 0)
        {
            csi_dev_err("sensor get af status err !\n");
            return ret;
        }
        cnt++;
        if(cnt>1000) {
            csi_dev_err("Single AF is timeout,value = 0x%x\n",regs.value[0]);
            return -EFAULT;
        }
    }
#else
    ;
#endif
    //csi_dev_print("Single AF is complete,value = 0x%x\n",regs.value[0]);
    return 0;
}
/* end add */




/*
 * supported color format list
 */
#if 0
static const struct ov5640_color_format ov5640_cfmts[] = {
{
    .code		= 2,//cym V4L2_MBUS_FMT_YUYV8_2X8_BE,
    .colorspace	= V4L2_COLORSPACE_JPEG,
},
{
    .code		= 3, //cym V4L2_MBUS_FMT_YUYV8_2X8_LE,
    .colorspace	= V4L2_COLORSPACE_JPEG,
},
{
    .code           = 0x2007, //cym V4L2_MBUS_FMT_YUYV8_2X8_LE,
    .colorspace     = V4L2_COLORSPACE_JPEG,
},
};
#endif

static const struct ov5640_color_format ov5640_cfmts[] = {
{
    .code		= V4L2_MBUS_FMT_YUYV8_2X8,
    .colorspace	=   V4L2_COLORSPACE_JPEG,
},
{
    .code		= V4L2_MBUS_FMT_UYVY8_2X8,
    .colorspace	= V4L2_COLORSPACE_JPEG,
},
{
    .code		= V4L2_MBUS_FMT_YVYU8_2X8,
    .colorspace	= V4L2_COLORSPACE_JPEG,
},
{
    .code		= V4L2_MBUS_FMT_VYUY8_2X8,
    .colorspace	= V4L2_COLORSPACE_JPEG,
},
};

static inline void init_setting_values(struct ov5640_priv *priv)
{
    priv->nflip_flag = OV5640_HFLIP;
}


/**
 * video ops
 */

static int ov5640_video_probe(struct i2c_client *client)
{
    //struct i2c_client *client = v4l2_get_subdevdata(sd);

    unsigned char pid;
    unsigned char version;
    //int err = -EINVAL;


    // check and show product ID and manufacturer ID
    i2cc_get_reg(client, 0x300a, &pid);
    i2cc_get_reg(client, 0x300b, &version);

    printk("%s: version = 0x%x%x\n", __FUNCTION__, pid, version);

    if (OV5640 != VERSION(pid, version)) {
        OV_ERR("ov5640 probed failed!!\n");
        return (-ENODEV);
    }

    //priv->nmodel = V4L2_IDENT_AMBIGUOUS;


    INFO_BLUE("ov5640 device detect success\n");

    return 0;
}

static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
{

      struct i2c_client *client = v4l2_get_subdevdata(sd);
      struct ov5640_priv *priv = to_ov5640(client);

    int ret = 0;

    printk("%s: enable %d, initialized %d\n", __func__, enable, priv->initialized);
    if (enable)
    {
        if (!priv->win || !priv->cfmt) {
            dev_err(&client->dev, "norm or win select error\n");
            return -EPERM;
        }
         /* write init regs */
        if (!priv->initialized) {
         //   if (!check_id(client))
              //  return -EINVAL;

             ov5640_video_probe(client);

#if 1
             reset_ov5640(client);

            printk("%s  line %d init ov5640 regs...........\n",__func__,__LINE__);
         //   ret = write_regs(client, sensor_init_data,ARRAY_SIZE(sensor_init_data));
            int ret = write_regs(client, ov5640_init_regs,ARRAY_SIZE(ov5640_init_regs));
            if (ret < 0)
            {
                printk(KERN_ERR "%s: failed to ov5640 init regs\n", __func__);
                return -EIO;
            }
#endif


       //  OV5640YUVPreview();



#if 1
            //this is very important,it must be CCIR656 enable,and after init ov5640 regs.
            printk("%s  line %d  ..CCIR656 CTRL00 enable .....\n",__func__,__LINE__);
            i2cc_set_reg(client, 0x4730,0x01);

            printk("%s  line %d  ..clock from PLL input........\n",__func__,__LINE__);
            i2cc_set_reg(client, 0x3103,0x03);  //clock from PLL input
#endif

            priv->initialized = true;
        }



#if 1

          printk("%s  line %d  ..set width=%d height=%d........\n",__func__,__LINE__,priv->win->width,priv->win->height);
          int ret = write_regs_flags(client, priv->win->regs);
          if (ret < 0)
          {
              printk(KERN_ERR "%s: failed to ov5640 size regs\n", __func__);
              return -EIO;
          }


#if 0
        //width 640
          i2cc_set_reg(client, 0x3808, 0x02);
          i2cc_set_reg(client, 0x3809, 0x80);

          //height  480
          i2cc_set_reg(client, 0x380a, 0x01);
          i2cc_set_reg(client, 0x380b, 0xe0);
#endif


//        ret = sp2518_set_mbusformat(client, priv->cfmt);
  //      if (ret < 0) {
    //        printk(KERN_ERR "%s: failed to sp2518_set_mbusformat()\n", __func__);
      //      return -EIO;
           //yuyv
          printk("%s  line %d  ..set yuyv format.......\n",__func__,__LINE__);
          i2cc_set_reg(client, 0x4300, 0x30);
          i2cc_set_reg(client, 0x501f, 0x00);



#if 0
          mdelay(100);

          if(0 == down_af_firmware_flag)
          {
              ov5640_sensor_download_af_fw(sd);

              down_af_firmware_flag = 1;
          }

          ov5640_sensor_s_single_af(sd);
#endif


#endif


    } else
    {

        //sp2518_write_array(client, sp2518_disable_regs);

        INFO_PURLPLE("stream down\n");
        // set regs to enter sleep mode, already in DVP mode
        i2cc_set_reg(client, 0x3008, 0x42);

    }

    return ret;
}





static int ov5640_set_brightness(struct i2c_client *client, int bright)
{
    struct ov5640_priv *priv = to_ov5640(client);
    unsigned char reg5587, reg5588;

    if (bright < -4 || 4 < bright) {
        OV_ERR("brightness - %d is out of range[-4, 4]\n", bright);
        return (-ERANGE);
    }

    if (bright < 0) {
        reg5587 = 0x10 * (-bright);
        reg5588 = 0x09; /* bit[3] is Y bright sign */
    } else {
        reg5587 = 0x10 * bright;
        reg5588 = 0x01;
    }

    i2cc_set_reg(client, 0x5001, 0xff);
    i2cc_set_reg(client, 0x5587, reg5587);
    i2cc_set_reg(client, 0x5580, 0x04);
    i2cc_set_reg(client, 0x5588, reg5588);
    priv->nbrightness = bright;
    OV_INFO("brightness:%d, reg5587:0x%x, reg5588:0x%x\n",
            bright, reg5587, reg5588);
    return (0);
}


static int ov5640_set_contrast(struct i2c_client *client, int contrast)
{
    struct ov5640_priv *priv = to_ov5640(client);
    unsigned char y_gain, reg5588;

    if (contrast < -4 || 4 < contrast) {
        OV_ERR("contrast - %d is out of range[-4, 4]\n", contrast);
        return (-ERANGE);
    }

    if (0 == contrast) {
        reg5588 = 0x1;
    } else {
        reg5588 = 0x41;
    }
    y_gain = 0x20 + 0x4 * contrast;

    i2cc_set_reg(client, 0x5001, 0xff);
    i2cc_set_reg(client, 0x5580, 0x04);
    i2cc_set_reg(client, 0x5586, y_gain);
    i2cc_set_reg(client, 0x5585, y_gain);
    i2cc_set_reg(client, 0x5588, reg5588);
    priv->ncontrast = contrast;

    OV_INFO("contrast:%d, y_gain:0x%x, reg5588:0x%x\n", contrast, y_gain, reg5588);
    return (0);
}


/* auto, manual seperated is ok?? */
static int ov5640_set_saturation(struct i2c_client *client, int saturation)
{
    struct ov5640_priv *priv = to_ov5640(client);
    unsigned char uv_max, uv_min, reg5588;

    if (saturation < -4 || 4 < saturation) {
        OV_ERR("saturation - %d is out of range[-4, 4]\n", saturation);
        return (-ERANGE);
    }

    if (0 == saturation) {  /* different from application notes */
        uv_max = 0x40;   /* max value for UV adjust */
        uv_min = 0x10;   /* min value for UV adjust */
        reg5588 = 0x01;  /* bit[6]==0, auto saturation */
    } else {
        uv_max = 0x40 + 0x10 * saturation; /* U sat. */
        uv_min = uv_max; /* v sat */
        reg5588 = 0x41;  /* bit[6]==1, manual saturation */
    }

    i2cc_set_reg(client, 0x5001, 0xff);  /* init is 0xa3 */
    i2cc_set_reg(client, 0x5583, uv_max);
    i2cc_set_reg(client, 0x5584, uv_min);
    i2cc_set_reg(client, 0x5580, 0x02);  /* bit[1], enable(1)/disabe(0) saturation */
    i2cc_set_reg(client, 0x5588, reg5588);
    priv->nsaturation = saturation;
    OV_INFO("saturation:%d\n", saturation);
    return (0);
}

/* XXX:effect is reversed to note's picture exept -180. check it */
static int ov5640_set_hue(struct i2c_client *client, int hue)
{
    struct ov5640_priv *priv = to_ov5640(client);
    unsigned char reg5581, reg5582, reg5588;

    switch (hue) {
    case -180:
        reg5581 = 0x80;
        reg5582 = 0x00;
        reg5588 = 0x32;
        break;
    case -150:
        reg5581 = 0x6f;
        reg5582 = 0x40;
        reg5588 = 0x32;
        break;
    case -120:
        reg5581 = 0x40;
        reg5582 = 0x6f;
        reg5588 = 0x32;
        break;
    case -90:
        reg5581 = 0x00;
        reg5582 = 0x80;
        reg5588 = 0x02;
        break;
    case -60:
        reg5581 = 0x40;
        reg5582 = 0x6f;
        reg5588 = 0x02;
        break;
    case -30:
        reg5581 = 0x6f;
        reg5582 = 0x40;
        reg5588 = 0x02;
        break;
    case 0:
        reg5581 = 0x80;
        reg5582 = 0x00;
        reg5588 = 0x01;
        break;
    case 30:
        reg5581 = 0x6f;
        reg5582 = 0x40;
        reg5588 = 0x01;
        break;
    case 60:
        reg5581 = 0x40;
        reg5582 = 0x6f;
        reg5588 = 0x01;
        break;
    case 90:
        reg5581 = 0x00;
        reg5582 = 0x80;
        reg5588 = 0x31;
        break;
    case 120:
        reg5581 = 0x40;
        reg5582 = 0x6f;
        reg5588 = 0x31;
        break;
    case 150:
        reg5581 = 0x6f;
        reg5582 = 0x40;
        reg5588 = 0x31;
        break;
    default:
        OV_ERR("hue - %d is out of range[-180, 150]/step-30\n", hue);
        return (-ERANGE);
    }

    i2cc_set_reg(client, 0x5001, 0xff);
    i2cc_set_reg(client, 0x5580, 0x01);  /* XXXX:diff. from defualt value */
    i2cc_set_reg(client, 0x5581, reg5581);  /* hue cos coefficient */
    i2cc_set_reg(client, 0x5582, reg5582);  /* hue sin coefficient */
    i2cc_set_reg(client, 0x5588, reg5588);
    priv->nhue = hue;
    OV_INFO("hue: %d, 5581:0x%x, 5582:0x%x, 5588:0x%x\n",
            hue, reg5581, reg5582, reg5588);

    return (0);
}


/* default value here is different from init one. */
static int ov5640_set_exposure_level(struct i2c_client *client, int level)
{
    struct ov5640_priv *priv = to_ov5640(client);
    unsigned char reg3a0f, reg3a10;
    unsigned char reg3a1b, reg3a1e;
    unsigned char reg3a11, reg3a1f;

    reg3a0f = 0x38 + 0x8 * level;
    reg3a10 = 0x30 + 0x8 * level;
    reg3a1b = reg3a0f;
    reg3a1e = reg3a10;
    reg3a1f = 0x10;

    switch (level) {
    case -5:  /* -1.7EV */
        reg3a11 = 0x20;
        break;
    case -4:  /* -1.3EV */
        reg3a11 = 0x30;
        break;
    case -3:  /* -1.0EV */
        reg3a11 = 0x41;
        break;
    case -2:  /* -0.7EV */
        reg3a11 = 0x51;
        break;
    case -1:  /* -0.3EV */
        reg3a11 = 0x61;
        break;
    case 0:  /* 0EV, default */
        reg3a11 = 0x61;
        break;
    case 1:  /* 0.3EV */
        reg3a11 = 0x71;
        break;
    case 2:  /* 0.7EV */
        reg3a11 = 0x80;
        reg3a1f = 0x20;
        break;
    case 3:  /* 1.0EV */
        reg3a11 = 0x90;
        reg3a1f = 0x20;
        break;
    case 4:  /* 1.3EV */
        reg3a11 = 0x91;
        reg3a1f = 0x20;
        break;
    case 5:  /* 1.7EV */
        reg3a11 = 0xa0;
        reg3a1f = 0x20;
        break;
    default:
        OV_ERR("exposure - %d is out of range[-5, 5]\n", level);
        return (-ERANGE);
    }

    OV_INFO("exposure: %d, 0x3a0f:0x%x, 0x3a10:0x%x\n", level, reg3a0f, reg3a10);
    //OV_INFO("0x3a1b:0x%x, 0x3a1e:0x%x\n", reg3a1b, reg3a1e);
    OV_INFO("0x3a11:0x%x, 0x3a1f:0x%x\n\n", reg3a11, reg3a1f);

    i2cc_set_reg(client, 0x3a0f, reg3a0f);  /* stable range high limit(enter) */
    i2cc_set_reg(client, 0x3a10, reg3a10);  /* stable range low limit(enter) */
    i2cc_set_reg(client, 0x3a11, reg3a11);  /* fast zone high limit */
    i2cc_set_reg(client, 0x3a1b, reg3a1b);  /* stable range high limit(go out) */
    i2cc_set_reg(client, 0x3a1e, reg3a1e);  /* stable range low limit(go out) */
    i2cc_set_reg(client, 0x3a1f, reg3a1f);  /* fast zone low limit */
    priv->nexposure = level;

    return (0);
}




#define OV5640_FLIP_VAL  ((unsigned char)0x06)
#define OV5640_FLIP_MASK (~(OV5640_FLIP_VAL))
static int ov5640_set_flip(struct i2c_client *client, struct v4l2_control *ctrl)
{
    struct ov5640_priv *priv = to_ov5640(client);
    unsigned char reg3820, reg3821;

    OV_INFO("old flag: %d\n", priv->nflip_flag);

    switch (ctrl->id) {
    case V4L2_CID_HFLIP:
        if (ctrl->value) {
            priv->nflip_flag |= OV5640_HFLIP;
        } else {
            priv->nflip_flag &= ~OV5640_HFLIP;
        }
        break;
    case V4L2_CID_VFLIP:
        if (ctrl->value) {
            priv->nflip_flag |= OV5640_VFLIP;
        } else {
            priv->nflip_flag &= ~OV5640_VFLIP;
        }
        break;
    default:
        OV_ERR("set flip out of range\n");
        return (-ERANGE);
    }

    OV_INFO("new flag: %d\n", priv->nflip_flag);

    i2cc_get_reg(client, 0x3820, &reg3820);
    i2cc_get_reg(client, 0x3821, &reg3821);

    if (priv->nflip_flag & OV5640_VFLIP) {
        reg3820 |= OV5640_FLIP_VAL;
    } else {
        reg3820 &= OV5640_FLIP_MASK;
    }

    if (priv->nflip_flag & OV5640_HFLIP) {
        reg3821 |= OV5640_FLIP_VAL;
    } else {
        reg3821 &= OV5640_FLIP_MASK;
    }

    /* have a bug which flip a half picture only. */
    //i2cc_set_reg(client, 0x3212, 0x00);   /* enable group0, when add no flip */
    i2cc_set_reg(client, 0x3820, reg3820);
    i2cc_set_reg(client, 0x3821, reg3821);
    //i2cc_set_reg(client, 0x3212, 0x10);   /* end group0 */
    //i2cc_set_reg(client, 0x3212, 0xa1);   /* launch group1 */
    OV_INFO("0x3820:0x%x, 0x3821:0x%x\n", reg3820, reg3821);

    return (0);
}

static int ov5640_set_sharpness(struct i2c_client *client, int sharp)
{
    struct ov5640_priv *priv = to_ov5640(client);
    unsigned char reg5302;

    switch (sharp) {
    case -1:  /*auto sharpness*/
        break;
    case 0:   /* sharpness off */
        reg5302 = 0x00;
        break;
    case 1:
        reg5302 = 0x02;
        break;
    case 2:
        reg5302 = 0x04;
        break;
    case 3:
        reg5302 = 0x08;
        break;
    case 4:
        reg5302 = 0x0c;
        break;
    case 5:
        reg5302 = 0x10;
        break;
    case 6:
        reg5302 = 0x14;
        break;
    case 7:
        reg5302 = 0x18;
        break;
    case 8:
        reg5302 = 0x20;
        break;
    default:
        OV_ERR("set sharpness is out of range - %d[-1,8]\n", sharp);
        return (-ERANGE);

    }

    if (0 <= sharp) {
        i2cc_set_reg(client, 0x5308, 0x65);
        i2cc_set_reg(client, 0x5302, reg5302);
        OV_INFO("sharp:%d, 5302:0x%x\n", sharp, reg5302);
    } else {
        const struct regval ov5640_auto_sharpness[] = {
        {0x5308, 0x25},
        {0x5300, 0x08},
        {0x5301, 0x30},
        {0x5302, 0x10},
        {0x5303, 0x00},
        {0x5309, 0x08},
        {0x530a, 0x30},
        {0x530b, 0x04},
        {0x530c, 0x06},
    };
        int len = ARRAY_SIZE(ov5640_auto_sharpness);
        write_regs(client, ov5640_auto_sharpness, len);
        OV_INFO("sharp:%d, len:%d\n", sharp, len);
    }
    priv->nsharpness = sharp;

    return (0);
}


static int ov5640_set_colorfx(struct i2c_client *client, int effect)
{
    struct ov5640_priv *priv = to_ov5640(client);
    unsigned char reg5583, reg5584, reg5001, reg5580;

    reg5001 = 0xff;
    reg5580 = 0x18;
    switch (effect) {
    case 0: /* normal */
        reg5001 = 0x7f;
        reg5580 = 0x00;
        break;
    case 1: /* black and white */
        reg5583 = 0x80;
        reg5584 = 0x80;
        break;
    case 2: /* sepia , antique */
        reg5583 = 0x40;
        reg5584 = 0xa0;
        break;
    case 3: /* negative */
        reg5001 = 0xff;
        reg5580 = 0x40;
        break;
    case 4: /* bluish */
        reg5583 = 0xa0;
        reg5584 = 0x40;
        break;
    case 5: /* greenish */
        reg5583 = 0x60;
        reg5584 = 0x60;
        break;
    case 6: /* reddish */
        reg5583 = 0x80;
        reg5584 = 0xc0;
        break;
    default:
        OV_ERR("set color effects out of range - %d[0,6]\n", effect);
        return (-ERANGE);

    }

    i2cc_set_reg(client, 0x5001, reg5001);
    i2cc_set_reg(client, 0x5580, reg5580);
    OV_INFO("effect:%d, 0x5001:0x%x, 0x5580:0x%x\n", effect, reg5001, reg5580);
    if (0 != effect && 3 != effect) {
        i2cc_set_reg(client, 0x5583, reg5583);
        i2cc_set_reg(client, 0x5584, reg5584);
        OV_INFO("0x5583:0x%x, 0x5584:0x%x\n", reg5583, reg5584);
    }

    priv->ncolorfx = effect;
    return (0);

}


static int ov5640_s_ctrl_exynos4412(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
        struct i2c_client *client = v4l2_get_subdevdata(sd);
        //struct ov5640_priv *priv = to_ov5640(client);
        int ret = 0;
        //int val = 0;

        /* add by cym 20130812 */
        int err = 0;
        //int value = ctrl->value;
        /* end add */

        OV_INFO("%s: control ctrl- %s\n", __func__, v4l2_ctrl_get_name(ctrl->id));
        printk("%s: control ctrl- id = %d\n", __func__, ctrl->id-V4L2_CID_PRIVATE_BASE);

        switch (ctrl->id) {
        case V4L2_CID_BRIGHTNESS:
                ov5640_set_brightness(client, ctrl->value);
                break;

        case V4L2_CID_CONTRAST:
                ov5640_set_contrast(client, ctrl->value);
                break;

        case V4L2_CID_SATURATION:
                ov5640_set_saturation(client, ctrl->value);
                break;

        case V4L2_CID_HUE:
                ov5640_set_hue(client, ctrl->value);
                break;
#if 0

//	case V4L2_CID_BLACK_LEVEL:
//		ov5640_set_black_level(sd, ctrl->value);
//		break;

        case V4L2_CID_AUTO_WHITE_BALANCE:
                ov5640_set_awb(client, ctrl->value);
                break;
//	case V4L2_CID_DO_WHITE_BALANCE:
//		ov5640_set_do_white_balance(sd, ctrl->value);
//		break;
//	case V4L2_CID_RED_BALANCE:
//		ov5640_set_red_balance(sd, ctrl->value);
//		break;
//	case V4L2_CID_BLUE_BALANCE:
//		ov5640_set_blue_balance(sd, ctrl->value);
//		break;
//	case V4L2_CID_GAMMA:
//		ov5640_set_gamma(sd, ctrl->value);
//		break;
#endif
        case V4L2_CID_EXPOSURE:
                ov5640_set_exposure_level(client, ctrl->value);
                break;
#if 0
        case V4L2_CID_AUTOGAIN:
                ov5640_set_autogain(sd, ctrl->value);
                break;
        case V4L2_CID_GAIN:
                ov5640_set_gain(sd, ctrl->value);
                break;
#endif
        case V4L2_CID_HFLIP:
        case V4L2_CID_VFLIP:
        ov5640_set_flip(client, ctrl);
        break;
#if 0
        case V4L2_CID_POWER_LINE_FREQUENCY:
                ov5640_set_power_line_frequency(sd, ctrl->value);
                break;
//	case V4L2_CID_HUE_AUTO:
//		ov5640_set_hue_auto(sd, ctrl->value);
//		break;

        case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
                set_white_balance_temperature(client, ctrl->value);
                break;
#endif
        case V4L2_CID_SHARPNESS:
                ov5640_set_sharpness(client, ctrl->value);
                break;
//	case V4L2_CID_BACKLIGHT_COMPENSATION:
//		ov5640_set_backlight_compensation(sd, ctrl->value);
//		break;
//	case V4L2_CID_CHROMA_AGC:
//		ov5640_set_chroma_agc(sd, ctrl->value);
//		break;
//	case V4L2_CID_CHROMA_GAIN:
//		ov5640_set_chroma_gain(sd, ctrl->value);
//		break;
//	case V4L2_CID_COLOR_KILLER:
//		ov5640_set_color_killer(sd, ctrl->value);
//		break;

        case V4L2_CID_COLORFX:
                ov5640_set_colorfx(client, ctrl->value);
                break;
#if 0
//	case V4L2_CID_AUTOBRIGHTNESS:
//		ov5640_set_autobrightness(sd, ctrl->value);
//		break;

        case V4L2_CID_BAND_STOP_FILTER:
                ov5640_set_band_stop_filter(sd, ctrl->value);
                break;

//	case V4L2_CID_ROTATE:
//		ov5640_set_rotate(sd, ctrl->value);
//		break;
//	case V4L2_CID_BG_COLOR:
//		ov5640_set_bg_color(sd, ctrl->value);
//		break;

        case V4L2_CID_EXPOSURE_AUTO:
                ov5640_set_exposure_auto(sd, ctrl->value);
                break;

//	case V4L2_CID_EXPOSURE_ABSOLUTE:
//	case V4L2_CID_EXPOSURE_AUTO_PRIORITY:
//	case V4L2_CID_PAN_RELATIVE:
//	case V4L2_CID_TILT_RELATIVE:
//	case V4L2_CID_PAN_RESET:
//	case V4L2_CID_TILT_RESET:
//	case V4L2_CID_PAN_ABSOLUTE:
//	case V4L2_CID_TILT_ABSOLUTE:
//	case V4L2_CID_FOCUS_ABSOLUTE:
//	case V4L2_CID_FOCUS_RELATIVE:
//	case V4L2_CID_FOCUS_AUTO:
//	case V4L2_CID_ZOOM_ABSOLUTE:
//	case V4L2_CID_ZOOM_RELATIVE:
//	case V4L2_CID_ZOOM_CONTINUOUS:
//	case V4L2_CID_IRIS_ABSOLUTE:
//	case V4L2_CID_IRIS_RELATIVE:
//	case V4L2_CID_PRIVACY:

        case V4L2_CID_SCENE_EXPOSURE:
                ov5640_set_scene_exposure(sd, ctrl->value);
                break;
#endif
        /* add by cym 20130812 */
      //  case V4L2_CID_CAMERA_SET_AUTO_FOCUS:
              //  printk("auto focus\n");
              //  err = ov5640_sensor_s_single_af(sd);
              break;
        /* end add */
        default:
                OV_ERR("invalid control ctrl: %s\n", v4l2_ctrl_get_name(ctrl->id));
                return (-EINVAL);
        }

        return (ret);
}



/////////////////////////////base v4l2 controls ///////////////////////////////////////////////////////////

static inline struct v4l2_subdev *ov5640_ctrl_to_sd(struct v4l2_ctrl *ctrl)
{
    return &container_of(ctrl->handler, struct ov5640_priv, hdl)->subdev;
}

static int ov5640_set_params(struct v4l2_subdev *sd, u32 *width, u32 *height, enum v4l2_mbus_pixelcode code)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct ov5640_priv *priv = to_ov5640(client);
    const struct ov5640_win_size *old_win, *new_win;
    int i;

    /*
     * select format
     */
    priv->cfmt = NULL;
    for (i = 0; i < ARRAY_SIZE(ov5640_cfmts); i++) {
        if (code == ov5640_cfmts[i].code) {
            priv->cfmt = ov5640_cfmts + i;
            break;
        }
    }
    if (!priv->cfmt) {
        printk(KERN_ERR "Unsupported sensor format.\n");
        return -EINVAL;
    }

    /*
     * select win
     */
    old_win = priv->win;
    new_win = select_win(*width, *height);
    if (!new_win) {
        printk(KERN_ERR "Unsupported win size\n");
        return -EINVAL;
    }
    priv->win = new_win;

    priv->rect.left = 0;
    priv->rect.top = 0;
    priv->rect.width = priv->win->width;
    priv->rect.height = priv->win->height;

    *width = priv->win->width;
    *height = priv->win->height;

     printk("%s....%d\n",__FUNCTION__,__LINE__);

    return 0;
}

/****************************************************************************************
 * control functions
 */

static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
{
    struct v4l2_subdev *sd = ov5640_ctrl_to_sd(ctrl);
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    int ret = 0;

    OV_INFO("%s: control ctrl- %s\n", __func__, v4l2_ctrl_get_name(ctrl->id));

    return;

    switch (ctrl->id) {
        case V4L2_CID_BRIGHTNESS:
            ov5640_set_brightness(sd, ctrl->val);
            break;

        case V4L2_CID_CONTRAST:
            ov5640_set_contrast(sd, ctrl->val);
            break;

        case V4L2_CID_AUTO_WHITE_BALANCE:
         //   ov5640_set_awb(sd, ctrl->value);
            break;

        case V4L2_CID_EXPOSURE:
            ov5640_set_exposure_level(sd, ctrl->val);
            break;

        case V4L2_CID_GAIN:
          //    ov5640_set_gain(sd, ctrl->val);
            break;

        case V4L2_CID_HFLIP:
             ov5640_set_flip(client, ctrl);
            break;

        case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
          //  set_white_balance_temperature(client, ctrl->val);
            break;

        case V4L2_CID_COLORFX:
             ov5640_set_colorfx(client, ctrl->val);
            break;

        case V4L2_CID_EXPOSURE_AUTO:
           //  ov5640_set_exposure_auto(sd, ctrl->val);
            break;

        case V4L2_CID_SCENE_EXPOSURE:
           //  ov5640_set_scene_exposure(sd, ctrl->val);
            break;

        case V4L2_CID_PRIVATE_PREV_CAPT:
           // sp2518_set_prev_capt_mode(sd, ctrl);
            break;

        default:
            dev_err(&client->dev, "%s: invalid control id %d\n", __func__, ctrl->id);
            return -EINVAL;
    }

    return ret;
}




static const struct v4l2_ctrl_ops ov5640_ctrl_ops = {
    .s_ctrl = ov5640_s_ctrl,
};

static const struct v4l2_ctrl_config ov5640_custom_ctrls[] = {
    {
        .ops    = &ov5640_ctrl_ops,
        .id     = V4L2_CID_SCENE_EXPOSURE,
        .type   = V4L2_CTRL_TYPE_INTEGER,
        .name   = "SceneExposure",
        .min    = 0,
        .max    = 1,
        .def    = 0,
        .step   = 1,
    }, {
        .ops    = &ov5640_ctrl_ops,
        .id     = V4L2_CID_PRIVATE_PREV_CAPT,
        .type   = V4L2_CTRL_TYPE_INTEGER,
        .name   = "PrevCapt",
        .min    = 0,
        .max    = 1,
        .def    = 0,
        .step   = 1,
    }
};

static int ov5640_initialize_ctrls(struct ov5640_priv *priv)
{
    v4l2_ctrl_handler_init(&priv->hdl, NUM_CTRLS);

    /* standard ctrls */
    priv->pbrightness = v4l2_ctrl_new_std(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_BRIGHTNESS, 0, 6, 1, 0);
    if (!priv->pbrightness) {
        printk(KERN_ERR "%s: failed to create brightness ctrl\n", __func__);
        return -ENOENT;
    }

    priv->pcontrast = v4l2_ctrl_new_std(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_CONTRAST, -6, 6, 1, 0);
    if (!priv->pcontrast) {
        printk(KERN_ERR "%s: failed to create contrast ctrl\n", __func__);
        return -ENOENT;
    }

    priv->pauto_white_balance = v4l2_ctrl_new_std(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);
    if (!priv->pauto_white_balance) {
        printk(KERN_ERR "%s: failed to create auto_white_balance ctrl\n", __func__);
        return -ENOENT;
    }

#if 0
    priv->pexposure = v4l2_ctrl_new_std(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_EXPOSURE, 0, 0xFFFF, 1, 500);
    if (!priv->pexposure) {
        printk(KERN_ERR "%s: failed to create exposure ctrl\n", __func__);
        return -ENOENT;
    }
#endif

    priv->pgain = v4l2_ctrl_new_std(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_GAIN, 0, 0xFF, 1, 128);
    if (!priv->pgain) {
        printk(KERN_ERR "%s: failed to create gain ctrl\n", __func__);
        return -ENOENT;
    }

    priv->phflip = v4l2_ctrl_new_std(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_HFLIP, 0, 1, 1, 0);
    if (!priv->phflip) {
        printk(KERN_ERR "%s: failed to create hflip ctrl\n", __func__);
        return -ENOENT;
    }

    priv->pwhite_balance_temperature = v4l2_ctrl_new_std(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_WHITE_BALANCE_TEMPERATURE, 0, 3, 1, 1);
    if (!priv->pwhite_balance_temperature) {
        printk(KERN_ERR "%s: failed to create white_balance_temperature ctrl\n", __func__);
        return -ENOENT;
    }

    /* standard menus */
    priv->pcolorfx = v4l2_ctrl_new_std_menu(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_COLORFX, 3, 0, 0);
    if (!priv->pcolorfx) {
        printk(KERN_ERR "%s: failed to create colorfx ctrl\n", __func__);
        return -ENOENT;
    }

    priv->pexposure_auto = v4l2_ctrl_new_std_menu(&priv->hdl, &ov5640_ctrl_ops,
            V4L2_CID_EXPOSURE_AUTO, 1, 0, 1);
    if (!priv->pexposure_auto) {
        printk(KERN_ERR "%s: failed to create exposure_auto ctrl\n", __func__);
        return -ENOENT;
    }

    /* custom ctrls */
    priv->pscene_exposure = v4l2_ctrl_new_custom(&priv->hdl, &ov5640_custom_ctrls[0], NULL);
    if (!priv->pscene_exposure) {
        printk(KERN_ERR "%s: failed to create scene_exposure ctrl\n", __func__);
        return -ENOENT;
    }

    priv->pprev_capt = v4l2_ctrl_new_custom(&priv->hdl, &ov5640_custom_ctrls[1], NULL);
    if (!priv->pprev_capt) {
        printk(KERN_ERR "%s: failed to create prev_capt ctrl\n", __func__);
        return -ENOENT;
    }

    priv->subdev.ctrl_handler = &priv->hdl;
    if (priv->hdl.error) {
        printk(KERN_ERR "%s: ctrl handler error(%d)\n", __func__, priv->hdl.error);
        v4l2_ctrl_handler_free(&priv->hdl);
        return -EINVAL;
    }


    printk("%s..................\n", __func__);

    return 0;
}





/****************************************************************************************
 * v4l2 subdev ops
 */

/**
 * core ops
 */
static int ov5640_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct ov5640_priv *priv = to_ov5640(client);
    id->ident    = priv->model;
    id->revision = 0;


    printk("%s: on  line %d \n", __func__, __LINE__);


    return 0;
}

static int ov5640_s_power(struct v4l2_subdev *sd, int on)
{
    /* used when suspending */
    printk("%s: on %d\n", __func__, on);
    if (!on) {

        struct i2c_client * client = v4l2_get_subdevdata(sd);
        struct ov5640_priv *priv = to_ov5640(client);
        priv->initialized = false;
    }

    return 0;
}

static const struct v4l2_subdev_core_ops ov5640_subdev_core_ops = {
    .g_chip_ident	=  ov5640_g_chip_ident ,//sp2518_g_chip_ident,
    .s_power        = ov5640_s_power,//sp2518_s_power,
    .s_ctrl         = v4l2_subdev_s_ctrl,
};

/**
 * video ops
 */

static int ov5640_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    printk("%s.............%d...........\n",__func__,__LINE__);

    if (fsize->index >= ARRAY_SIZE(ov5640_wins)) {
        dev_err(&client->dev, "index(%d) is over range %d  %s\n", fsize->index, ARRAY_SIZE(ov5640_wins),__func__);
        return -EINVAL;
    }

    switch (fsize->pixel_format) {
        case V4L2_PIX_FMT_YUV420:
        case V4L2_PIX_FMT_YUV422P:
        case V4L2_PIX_FMT_NV12:
        case V4L2_PIX_FMT_YUYV:
            fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
            fsize->discrete.width = 640;//ov5645_win[fsize->index]->width;
            fsize->discrete.height = 480;//ov5645_win[fsize->index]->height;
            break;
        default:
            dev_err(&client->dev, "pixel_format(%d) is Unsupported %s \n", fsize->pixel_format, __func__);
            return -EINVAL;
    }

     //printk("type %d, width %d, height %d\n", V4L2_FRMSIZE_TYPE_DISCRETE, fsize->discrete.width, fsize->discrete.height);

     printk("%s,%d,type %d, width %d, height %d\n", __func__,__LINE__, V4L2_FRMSIZE_TYPE_DISCRETE, fsize->discrete.width, fsize->discrete.height);

    return 0;
}



static int ov5640_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
        enum v4l2_mbus_pixelcode *code)
{
    if (index >= ARRAY_SIZE(ov5640_cfmts))
        return -EINVAL;

    *code = ov5640_cfmts[index].code;


    printk("%s, %d   index=%d\n", __func__, __LINE__,index);

    return 0;
}



static int ov5640_g_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct ov5640_priv *priv = to_ov5640(client);
    if (!priv->win || !priv->cfmt) {
        u32 width = 640; //SVGA_WIDTH;
        u32 height = 480 ; //SVGA_HEIGHT;
        int ret = ov5640_set_params(sd, &width, &height, V4L2_MBUS_FMT_UYVY8_2X8);
        if (ret < 0) {
            printk("%s, %d\n", __func__, __LINE__);
            return ret;
        }
    }

    mf->width   = priv->win->width;
    mf->height  = priv->win->height;
    mf->code    = priv->cfmt->code;
    mf->colorspace  = priv->cfmt->colorspace;
    mf->field   = V4L2_FIELD_NONE;

    printk("%s, %d\n", __func__, __LINE__);
    return 0;
}



static int ov5640_try_mbus_fmt(struct v4l2_subdev *sd,
        struct v4l2_mbus_framefmt *mf)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct ov5640_priv *priv = to_ov5640(client);
    const struct ov5640_win_size *win;
    int i;

    /*
     * select suitable win
     */
    win = select_win(mf->width, mf->height);
    if (!win)
        return -EINVAL;

    mf->width   = win->width;
    mf->height  = win->height;
    mf->field   = V4L2_FIELD_NONE;


    for (i = 0; i < ARRAY_SIZE(ov5640_cfmts); i++)
        if (mf->code == ov5640_cfmts[i].code)
            break;

    if (i == ARRAY_SIZE(ov5640_cfmts)) {
        /* Unsupported format requested. Propose either */
        if (priv->cfmt) {
            /* the current one or */
            mf->colorspace = priv->cfmt->colorspace;
            mf->code = priv->cfmt->code;
        } else {
            /* the default one */
            mf->colorspace = ov5640_cfmts[0].colorspace;
            mf->code = ov5640_cfmts[0].code;
        }
    } else {
        /* Also return the colorspace */
        mf->colorspace	= ov5640_cfmts[i].colorspace;
    }


    printk("%s, %d\n", __func__, __LINE__);

    return 0;
}


static int ov5640_s_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);
    struct ov5640_priv *priv = to_ov5640(client);

    int ret = ov5640_set_params(sd, &mf->width, &mf->height, mf->code);

    printk("%s(%d): rest = %d\n", __FUNCTION__, __LINE__, ret);

    if (!ret)
        mf->colorspace = priv->cfmt->colorspace;

    printk("%s....%d  colorspace is %d  code is %d \n",__FUNCTION__,__LINE__,priv->cfmt->colorspace,priv->cfmt->code);

    return ret;



}

static const struct v4l2_subdev_video_ops ov5640_subdev_video_ops = {
    .s_stream               = ov5640_s_stream,//sp2518_s_stream,
    .enum_framesizes        = ov5640_enum_framesizes,//sp2518_enum_framesizes,
    .enum_mbus_fmt          = ov5640_enum_mbus_fmt, //sp2518_enum_mbus_fmt,
    .g_mbus_fmt             = ov5640_g_mbus_fmt, //sp2518_g_mbus_fmt,
    .try_mbus_fmt           = ov5640_try_mbus_fmt, //sp2518_try_mbus_fmt,
    .s_mbus_fmt             = ov5640_s_mbus_fmt, //sp2518_s_mbus_fmt,
 };

/**
 * pad ops */
static int ov5640_s_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
        struct v4l2_subdev_format *fmt)
{
    struct v4l2_mbus_framefmt *mf = &fmt->format;
    printk("%s: %dx%d\n", __func__, mf->width, mf->height);

    return ov5640_s_mbus_fmt(sd, mf);



}

static const struct v4l2_subdev_pad_ops ov5640_subdev_pad_ops = {
    .set_fmt    =  ov5640_s_fmt, //first  call by hal
};

/**
 * subdev ops
 */
static const struct v4l2_subdev_ops ov5640_subdev_ops = {
    .core   = &ov5640_subdev_core_ops,
    .video  = &ov5640_subdev_video_ops,
    .pad    = &ov5640_subdev_pad_ops,
};

/**
 * media_entity_operations
 */
static int ov5640_link_setup(struct media_entity *entity,
        const struct media_pad *local,
        const struct media_pad *remote, u32 flags)
{
    printk("%s\n", __func__);
    return 0;
}

static const struct media_entity_operations ov5640_media_ops = {
    .link_setup = ov5640_link_setup,
};

/****************************************************************************************
 * initialize
 */


static void ov5640_priv_init(struct ov5640_priv * priv)
{
    priv->model = V4L2_IDENT_AMBIGUOUS;
    priv->prev_capt_mode = PREVIEW_MODE;
 //   priv->timeperframe.denominator = 12;//30;
 //   priv->timeperframe.numerator = 1;
 //   priv->win = &ov5640_wins_vga;
}




static int ov5640_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    struct ov5640_priv *priv;
    struct v4l2_subdev *sd;
    int ret;

    priv = (struct ov5640_priv *)kzalloc(sizeof(struct ov5640_priv), GFP_KERNEL);
    if (!priv)
        return -ENOMEM;

    ov5640_priv_init(priv);

    sd = &priv->subdev;
    strcpy(sd->name, MODULE_NAME);

    /* register subdev */
    v4l2_i2c_subdev_init(sd, client, &ov5640_subdev_ops);

    sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
  //  priv->pad.flags = MEDIA_PAD_FL_SOURCE;
    sd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
    sd->entity.ops  = &ov5640_media_ops;
    if (media_entity_init(&sd->entity, 1, &priv->pad, 0)) {
        dev_err(&client->dev, "%s: failed to media_entity_init()\n", __func__);
        kfree(priv);
        return -ENOENT;
    }

    ret = ov5640_initialize_ctrls(priv);
    if (ret < 0) {
        printk(KERN_ERR "%s: failed to initialize controls\n", __func__);
        kfree(priv);
        return ret;
    }

    g_client = client;

   printk("%s:%d.......\n", __func__, __LINE__);


    return 0;
}

static int ov5640_remove(struct i2c_client *client)
{
    struct v4l2_subdev *sd = i2c_get_clientdata(client);
    v4l2_device_unregister_subdev(sd);
    v4l2_ctrl_handler_free(sd->ctrl_handler);
    media_entity_cleanup(&sd->entity);
    kfree(to_ov5640(client));

    printk("%s: on %d line \n", __func__, __LINE__);

    return 0;
}

static const struct i2c_device_id ov5640_id[] = {
    { MODULE_NAME, 0 },
    { }
};

MODULE_DEVICE_TABLE(i2c, ov5640_id);

static struct i2c_driver ov5640_i2c_driver = {
    .driver = {
        .name = MODULE_NAME,
    },
    .probe    = ov5640_probe,
    .remove   = ov5640_remove,
    .id_table = ov5640_id,
};

module_i2c_driver(ov5640_i2c_driver);

MODULE_DESCRIPTION("SoC Camera driver for OV5640");
MODULE_AUTHOR("xunwei_dg@topeet.com)");
MODULE_LICENSE("GPL v2");
